{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"SJSS \u2014 Design Systems. Reimagined for Angular. <p>Build dynamic, token\u2011driven, and responsive UIs using Angular Signals. SJSS brings Tailwind\u2019s speed and MUI\u2019s theming \u2014 natively in Angular\u00a020.</p> <p> \ud83d\ude80 Get Started \ud83d\udc40 View Demo \ud83d\udcda Open Storybook \u26a1 Try on StackBlitz </p>"},{"location":"#super-jss-atomic-cssinjs-for-angular-20","title":"Super JSS \u2014 Atomic CSS\u2011in\u2011JS for Angular 20","text":"<p>Super JavaScript Stylesheets (SJSS) is a tiny, runtime styling library for Angular 20. It generates atomic CSS as you use it, supports responsive breakpoints and theming, and gives you a minimal, ergonomic API.</p> <ul> <li>\u26a1 Angular\u2011native: built on Signals</li> <li>\ud83c\udfaf Atomic CSS generation: only what you use</li> <li>\ud83d\udcf1 Responsive + theming: <code>xs\u2026xxl</code> breakpoints and palette tokens</li> <li>\ud83c\udfa8 Pseudo\u2011selectors: <code>&amp;:hover</code>, <code>&amp;:focus</code>, etc.</li> <li>\ud83e\udde9 Ready\u2011made building blocks: <code>&lt;sj-paper&gt;</code>, <code>&lt;sj-card&gt;</code>, <code>&lt;sj-button&gt;</code></li> </ul>"},{"location":"#important-links","title":"Important links","text":"<ul> <li>Documentation: https://sjss.dev</li> <li>Demo &amp; lib workspace (StackBlitz): https://stackblitz.com/~/github.com/rsantoyo-dev/super-jss-workspace?file=projects/super-jss-demo/src/app/app.component.ts</li> <li>GitHub repository: https://github.com/rsantoyo-dev/super-jss-workspace</li> <li>Deployed demo: https://sjssdemo.netlify.app/</li> <li>Storybook: https://sjss-storybook.netlify.app/</li> <li>NPM: https://www.npmjs.com/package/super-jss</li> <li>Open Source Licenses (OSI): https://opensource.org/licenses</li> </ul>"},{"location":"#why-sjss","title":"Why SJSS","text":"<ul> <li>Angular\u2011native, powered by Signals; no build\u2011time plugin required.</li> <li>Atomic CSS at runtime: ship only the CSS you use.</li> <li>Token\u2011driven theming with responsive objects on every property.</li> <li>Minimal, ergonomic API: write plain CSS (or shorthands) as TS objects.</li> </ul>"},{"location":"#compare-at-a-glance","title":"Compare at a glance","text":"Library Type Theming/Tokens Angular 20 Notes Tailwind CSS Utility framework Limited via config Generic Build\u2011time, globals Angular Material Component library Material tokens Yes Prescriptive UI components PrimeNG Component library Theme packs Yes Theming via CSS variables MUI (React) Component library Rich theming (React) No React\u2011only SJSS Styling library Tokens + responsive API Yes Atomic CSS\u2011in\u2011JS, Signals\u2011native"},{"location":"#install","title":"Install","text":"<pre><code>npm install super-jss\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<p>This minimal Hero shows inline <code>[sj]</code> styles, a one\u2011line theme update, and a reactive breakpoint log.</p> <pre><code>import { Component, effect, inject } from '@angular/core';\nimport { SJ_BASE_COMPONENTS_IMPORTS, SjThemeService, sj } from 'super-jss';\n\n@Component({\n  standalone: true,\n  selector: 'app-hero',\n  imports: [SJ_BASE_COMPONENTS_IMPORTS],\n  template: `\n    &lt;sj-host\n      [sj]=\"[\n        sj.display(sj.display.options.flex),\n        sj.flexDirection({ xs: sj.flexDirection.options.column, md: sj.flexDirection.options.row }),\n        sj.justifyContent(sj.justifyContent.options.center),\n        sj.alignItems(sj.alignItems.options.center),\n        sj.gap({ xs: 0.5, md: 1 }),\n        sj.p(2),\n        sj.bg(sj.bg.options.light.light)\n      ]\"\n    &gt;\n      &lt;sj-paper usePaint=\"primary\" useRounded=\"default\" usePadding=\"default\"&gt;\n        &lt;h1 [sj]=\"[ sj.m(0) ]\"&gt;Hello SJSS&lt;/h1&gt;\n      &lt;/sj-paper&gt;\n\n      &lt;sj-button\n        [sj]=\"[\n          sj.p(2),\n          sj.bg('primary.main'),\n          sj.c('white'),\n          sj.hover([ sj.backgroundColor(sj.bg.options.primary.dark) ])\n        ]\"\n        (click)=\"updatePrimaryColor()\"\n      &gt;\n        Update Primary\n      &lt;/sj-button&gt;\n    &lt;/sj-host&gt;\n  `,\n})\nexport class HeroComponent {\n  readonly theme = inject(SjThemeService);\n  readonly sj = sj;\n\n  // Log the current breakpoint reactively\n  private _bp = effect(() =&gt; console.log('breakpoint:', this.theme.breakpoint()));\n\n  // One\u2011liner theme update for primary color\n  updatePrimaryColor() {\n    this.theme.setTheme({\n      palette: { primary: { ...this.theme.sjTheme().palette.primary, main: '#4e3149ff' } } as any,\n    });\n  }\n}\n</code></pre>"},{"location":"#key-ideas","title":"Key ideas","text":"<ul> <li>camelCase CSS properties: <code>backgroundColor</code>, <code>justifyContent</code>, <code>borderRadius</code></li> <li>Responsive objects: <code>{ xs: 1, md: 2 }</code></li> <li>Theme tokens: <code>sj.palette.primary.main</code>, <code>sj.palette.light.dark</code></li> <li>Pseudo\u2011selectors: <code>sj.hover({ ... })</code>, <code>sj.focus({ ... })</code></li> </ul>"},{"location":"#minimal-api-surface-v1","title":"Minimal API surface (v1)","text":"<p>The root API gives you two things:</p> <p>1) Any CSS property function 2) A few curated shorthands with <code>.options</code></p> <pre><code>import { sj } from 'super-jss';\n\n// CSS properties\nsj.backgroundColor('primary.main');\nsj.padding({ xs: 1, md: 2 });\nsj.width(sj.width.options.fitContent);\nsj.position(sj.position.options.absolute);\n\n// Shorthands (popular)\nsj.p(2);         // padding\nsj.m({ md: 1 }); // margin\nsj.bg('primary.main');\nsj.c('primary.contrast');\n\n// Discoverable options for common props\nsj.display.options;         // { flex, grid, block, inline, inlineBlock, contents, none }\nsj.flexDirection.options;   // { row, rowReverse, column, columnReverse }\nsj.justifyContent.options;  // { flexStart, flexEnd, center, spaceBetween, spaceAround, spaceEvenly }\nsj.alignItems.options;      // { flexStart, flexEnd, center, stretch, baseline }\nsj.width.options;           // { auto, fitContent, maxContent, minContent }\nsj.height.options;          // { auto, fitContent, maxContent, minContent }\nsj.position.options;        // { static, relative, absolute, fixed, sticky }\n\n// Tokens available at root\nsj.palette.primary.main;\nsj.breakpoints.md;\n\n// Composition helpers\n// Prefer passing an array to [sj] instead of composing in TS\n</code></pre>"},{"location":"#components-and-blueprints","title":"Components and blueprints","text":"<p>Ship simple styles fast using built\u2011ins:</p> <pre><code>import { SJ_BASE_COMPONENTS_IMPORTS, sj } from 'super-jss';\n\n@Component({\n  standalone: true,\n  imports: [SJ_BASE_COMPONENTS_IMPORTS],\n  template: `\n    &lt;sj-paper usePadding=\"default\"&gt;Content&lt;/sj-paper&gt;\n    &lt;sj-card variant=\"elevated\" usePadding=\"default\"&gt;Card content&lt;/sj-card&gt;\n    &lt;sj-button variant=\"filled\" [sj]=\"{ w: 'fit-content' }\"&gt;Click&lt;/sj-button&gt;\n  `,\n})\nexport class DemoComponent {\n  box = [sj.p(1), sj.bg('light.light')];\n}\n</code></pre> <p>Blueprints are also callable:</p> <pre><code>sj.sjCard();                 // default card\nsj.sjCard.outlined();        // outlined\nsj.sjCard.elevated();        // elevated\n</code></pre>"},{"location":"#responsive-examples","title":"Responsive examples","text":"<pre><code>&lt;div\n  [sj]=\"[\n    sj.display('flex'),\n    sj.flexDirection({ xs: 'column', md: 'row' }),\n    sj.gap({ xs: 0.5, md: 1 }),\n  ]\"\n&gt;&lt;/div&gt;\n</code></pre>"},{"location":"#faq","title":"FAQ","text":"<p>Q: Why this approach vs. utility frameworks or huge token bags? A: SJSS generates only the atomic CSS you actually use, at runtime. No prebuilt megabundle. You write plain CSS properties, enhanced with <code>.options</code> for discoverability. Compared to utility-first CSS, you: (1) keep styling colocated with your component logic, (2) get type\u2011safe, theme\u2011aware values, and (3) ship less. Compared to heavy design-token bags, we keep only the essentials at root: <code>sj.palette</code> and <code>sj.breakpoints</code>.</p> <p>Q: How do I maintain theming long-term? A: Use semantic palette tokens everywhere (<code>'primary.main'</code>, <code>'light.dark'</code>). Centralize your theme in one place (theme service/config). Because styles reference semantic tokens, swapping a palette or adjusting contrast cascades automatically without touching components. Prefer semantic tokens over raw hex in app code.</p> <p>Q: What\u2019s the responsive story? A: Every property supports responsive objects: <code>{ xs, sm, md, lg, xl, xxl }</code>. This keeps responsive intent in one place per style. Example: <code>sj.flexDirection({ xs: 'column', md: 'row' })</code> and <code>sj.gap({ xs: 0.5, md: 1 })</code>.</p> <p>Q: Is it SSR\u2011friendly and fast? A: Yes. The library avoids direct DOM access during import and only generates minimal, deterministic atomic classes at runtime. Styles are memoized, deduped, and composed; pseudo\u2011selectors are compiled into atomic rules and reused. Result: tiny CSS, predictable ordering, and quick first paint.</p> <p>Q: How do I discover valid values fast? A: Use <code>.options</code> on common props: <code>sj.display.options</code>, <code>sj.flexDirection.options</code>, <code>sj.justifyContent.options</code>, <code>sj.alignItems.options</code>, <code>sj.width.options</code>, <code>sj.height.options</code>, <code>sj.position.options</code>. Your IDE will autocomplete ergonomic aliases like <code>spaceBetween</code>, <code>flexStart</code>, etc.</p> <p>Q: Can I mix literal values with tokens? A: Absolutely. Use literals where convenient (<code>'fit-content'</code>, <code>'1fr 2fr'</code>, <code>600</code>) and tokens for theme consistency (<code>'primary.main'</code>, <code>'neutral.contrast'</code>).</p> <p>Q: How do I center with flex quickly? A: <code>sj.display(sj.display.options.flex)</code>, <code>sj.justifyContent(sj.justifyContent.options.center)</code>, and <code>sj.alignItems(sj.alignItems.options.center)</code>. That\u2019s it.</p>"},{"location":"#support","title":"\ud83d\udc96 Support","text":"<p>If you find Super JSS useful, consider supporting its development:</p> <ul> <li>\u2615 \u2615 \u2615 Buy me a coffee</li> </ul>"},{"location":"#contact","title":"\ud83d\udcec Contact","text":"<p>For inquiries, feedback, or issues, reach out at ricardo.santoyo@hotmail.com.</p>"},{"location":"#license","title":"License","text":"<p>MIT \u00a9 Ricardo Santoyo</p>"},{"location":"basic-usage/","title":"Basic usage: the core of SJSS","text":"<p>SJSS centers around one idea: write styles as plain TypeScript objects (or arrays of them) and bind them to <code>[sj]</code>. You can use any camelCase CSS property and every property also accepts a responsive object.</p> <p>This page walks you from the simplest inline example to using the <code>sj</code> root API for autocomplete and discoverable options.</p>"},{"location":"basic-usage/#1-the-minimal-component-core-pattern","title":"1) The minimal component (core pattern)","text":"<pre><code>import { Component } from '@angular/core';\nimport { SjDirective } from 'super-jss';\n\n@Component({\n  standalone: true,\n  selector: 'app-demo',\n  imports: [SjDirective],\n  template: `\n    &lt;div [sj]=\"{ p: 2, bg: 'primary.main', color: 'primary.contrast' }\"&gt;\n      Welcome to Super JSS!\n    &lt;/div&gt;\n  `,\n})\nexport class DemoComponent {}\n</code></pre> <p>What\u2019s happening:</p> <ul> <li>CSS as TS object: properties are camelCase (<code>backgroundColor</code> \u2192 <code>backgroundColor</code>, or shorthand <code>bg</code>).</li> <li>Theme tokens: values like <code>'primary.main'</code> are resolved via the active theme.</li> <li>Atomic CSS at runtime: SJSS generates minimal CSS classes for you.</li> </ul>"},{"location":"basic-usage/#2-any-css-prop-supports-responsive-values","title":"2) Any CSS prop supports responsive values","text":"<p>Any property (or shorthand) can take a responsive object with breakpoint keys <code>{ xs, sm, md, lg, xl, xxl }</code>.</p> <pre><code>&lt;div [sj]=\"{\n  p: { xs: 1, md: 2 },\n  backgroundColor: { xs: 'light.main', md: 'primary.main' },\n  fontSize: { xs: 1, md: 1.25, lg: 1.5 }\n}\"&gt;&lt;/div&gt;\n</code></pre> <p>You can mix shorthands and full CSS names interchangeably.</p>"},{"location":"basic-usage/#3-arrays-compose-styles-left-right","title":"3) Arrays compose styles (left \u2192 right)","text":"<p><code>[sj]</code> also accepts an array. Later entries override earlier ones. This is a clean way to reuse and override.</p> <pre><code>import { Component } from '@angular/core';\nimport { SjDirective, SjStyle } from 'super-jss';\n\nconst base: SjStyle = { p: 1, bg: 'light.light', borderRadius: '6px' };\nconst interactive: SjStyle = {\n  cursor: 'pointer',\n  transition: 'all .2s ease',\n  '&amp;:hover': { bg: 'primary.main', color: 'primary.contrast' },\n};\n\n@Component({\n  standalone: true,\n  selector: 'app-compose',\n  imports: [SjDirective],\n  template: `\n    &lt;div [sj]=\"[ base, interactive, { p: { md: 2 } } ]\"&gt;Composed&lt;/div&gt;\n  `,\n})\nexport class ComposeComponent {\n  protected readonly base = base;\n  protected readonly interactive = interactive;\n}\n</code></pre>"},{"location":"basic-usage/#4-sjrootapi-functions-with-autocomplete-and-options","title":"4) sjRootApi: functions with autocomplete and <code>.options</code>","text":"<p>While plain objects work everywhere, using the <code>sj</code> helper unlocks great DX: typed functions for every CSS prop and curated shorthands\u2014each with discoverable <code>.options</code>.</p> <p>Expose <code>sj</code> to your template for autocomplete:</p> <pre><code>import { Component } from '@angular/core';\nimport { SjDirective, sj } from 'super-jss';\n\n@Component({\n  standalone: true,\n  selector: 'app-sj-api',\n  imports: [SjDirective],\n  template: `\n    &lt;div [sj]=\"[\n      sj.display(sj.display.options.flex),\n      sj.flexDirection({ xs: sj.flexDirection.options.column, md: sj.flexDirection.options.row }),\n      sj.justifyContent(sj.justifyContent.options.center),\n      sj.alignItems(sj.alignItems.options.center),\n      sj.p(2),\n      sj.bg(sj.bg.options.primary.main)\n    ]\"&gt;Using sjRootApi&lt;/div&gt;\n  `,\n})\nexport class SjApiComponent {\n  readonly sj = sj; // expose to template\n}\n</code></pre> <p>Highlights:</p> <ul> <li><code>sj.&lt;cssProp&gt;(value)</code> for any CSS prop, plus shorthands like <code>sj.p</code>, <code>sj.bg</code>, <code>sj.c</code>, <code>sj.gap</code>.</li> <li><code>.options</code> reveals common, typed values (e.g., <code>sj.display.options.flex</code>, <code>sj.position.options.absolute</code>).</li> <li>Works in arrays; combine with plain objects freely.</li> </ul> <p>See the full API: sj API and Styling shortcuts.</p>"},{"location":"basic-usage/#5-pseudoselectors-two-ways","title":"5) Pseudo\u2011selectors two ways","text":"<p>You can write pseudo\u2011selectors inline with <code>&amp;:</code> or use helpers that accept a style or an array of styles.</p> <pre><code>&lt;button [sj]=\"{\n  p: 1,\n  bg: 'secondary.main',\n  color: 'secondary.contrast',\n  '&amp;:hover': { bg: 'secondary.dark' },\n  '&amp;:active': { transform: 'scale(0.98)' }\n}\"&gt;Click&lt;/button&gt;\n</code></pre> <p>Or with helpers:</p> <pre><code>&lt;button [sj]=\"[\n  sj.p(1),\n  sj.bg('secondary.main'),\n  sj.c('secondary.contrast'),\n  sj.hover([ sj.bg('secondary.dark') ]),\n  sj.active({ transform: 'scale(0.98)' })\n]\"&gt;&lt;/button&gt;\n</code></pre>"},{"location":"basic-usage/#6-reuse-styles-from-typescript","title":"6) Reuse styles from TypeScript","text":"<p>Define <code>SjStyle</code> objects in code and merge them via an array in the template.</p> <pre><code>import { SjStyle, sj } from 'super-jss';\n\nconst cardBase: SjStyle = { p: 1, brad: 0.5, bg: 'light.light' };\n\nconst cardPrimary: SjStyle = { bg: 'primary.main', c: 'primary.contrast' };\n</code></pre>"},{"location":"basic-usage/#where-to-go-next","title":"Where to go next","text":"<ul> <li>Discover all functions and <code>.options</code>: sj API</li> <li>Popular shorthands: Styling shortcuts</li> <li>Responsive techniques: Responsive Style</li> <li>Themes and tokens: Theming</li> </ul> <p>Tip: You can also use the prebuilt components and blueprints for faster starts. See the homepage Quick Start and Components.</p>"},{"location":"color-sugars/","title":"Color sugars (useBg/useColor)","text":"<p>All base components (e.g., <code>&lt;sj-paper&gt;</code>, <code>&lt;sj-flex&gt;</code>) support two ergonomic color inputs:</p> <ul> <li><code>useBg</code>: sets the background color</li> <li><code>useColor</code>: sets the text color</li> </ul> <p>These sugars reuse the same token system as <code>[sj]</code>, so you can pass either:</p> <ul> <li>Palette tokens: <code>primary</code>, <code>primary.light</code>, <code>secondary.dark</code>, <code>light.light</code>, etc.</li> <li>Raw CSS colors: <code>#111</code>, <code>white</code>, <code>rgb(0 0 0 / 0.5)</code>, etc.</li> </ul>"},{"location":"color-sugars/#auto-contrast","title":"Auto-contrast","text":"<p>When <code>useBg</code> is a palette token, setting <code>useColor=\"auto\"</code> automatically applies <code>&lt;family&gt;.contrast</code> for accessible text. For example:</p> <pre><code>&lt;sj-paper [useBg]=\"'primary'\" [useColor]=\"'auto'\"&gt;Readable on primary&lt;/sj-paper&gt;\n</code></pre> <p>If you provide an explicit <code>useColor</code> (e.g., <code>useColor=\"white\"</code>), your value is used. The <code>[sj]</code> input always merges last and can override both.</p>"},{"location":"color-sugars/#precedence","title":"Precedence","text":"<ul> <li><code>[sj]</code> overrides everything</li> <li>Component sugars (like variant defaults, padding styles) come before base color sugars</li> <li>Base sugars (<code>useBg</code>, <code>useColor</code>) override component defaults</li> </ul> <p>This ensures you can quickly set a background/text color without losing the ability to refine styles with <code>[sj]</code>.</p>"},{"location":"color-sugars/#tips","title":"Tips","text":"<ul> <li>Use tokens for theme-aware colors and automatic contrast.</li> <li>Use raw CSS colors for ad-hoc shades or one-off demos.</li> <li>Set <code>useColor='none'</code> to skip text color if you only want to change the background.</li> </ul>"},{"location":"colors/","title":"Color palette and theming","text":"<p>Super JavaScript Stylesheets (SJSS) provides a flexible, token-based color system. You can use semantic palette tokens like <code>primary.main</code> or raw shade tokens like <code>blue.500</code> anywhere you style with <code>[sj]</code>.</p>"},{"location":"colors/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Using the color tokens</li> <li>Personalize the color palette</li> <li>Color palette default reference</li> </ol>"},{"location":"colors/#using-the-color-tokens","title":"Using the color tokens","text":"<p>Use <code>bg</code> for background and <code>c</code> for text color. Both palette tokens (e.g., <code>primary.*</code>) and shade tokens (e.g., <code>blue.500</code>) are supported in styles.</p> <pre><code>import { Component } from \"@angular/core\";\nimport { SjDirective } from \"super-jss\";\n\n  @Component({\n    standalone: true,\n    selector: 'app-colorful-component',\n    template: `\n      &lt;div [sj]=\"{ m: '2rem', p: '1rem', bg: 'blue.500' }\"&gt;\n       &lt;div [sj]=\"{ bg: 'orange.300', c: 'orange.contrast' }\"&gt;\n        This is a colorful component!\n       &lt;/div&gt;        \n      &lt;/div&gt;\n    `\n  })\n  export class ColorfulComponent {}\n</code></pre> <p>In this example, we set a background color with a raw shade token (<code>blue.500</code>), then a nested block with a shade background and its contrast text color from the same color family.</p>"},{"location":"colors/#personalize-the-color-palette","title":"Personalize the color palette","text":"<p>You can customize the raw shade map (<code>theme.colors</code>) via <code>SjThemeService.setTheme</code>. These shade maps power tokens like <code>blue.500</code> and include a <code>contrast</code> swatch commonly used for legible text.</p> <p>Any palette item is defined as:</p> <p><pre><code>  {\n    50: string,\n    100: string,\n    200: string,\n    300: string,\n    400: string,\n    500: string, // Default shade\n    600: string,\n    700: string,\n    800: string,\n    900: string,\n    contrast: string\n  } \n</code></pre> To update a color family, use the <code>setTheme</code> method from the <code>SjThemeService</code>:</p> <pre><code>import { Component } from \"@angular/core\";\nimport { SjDirective, SjThemeService } from \"super-jss\";\n\n@Component({\n  standalone: true,\n  selector: 'app-palette-update-demo',\n  template: `\n    &lt;button (click)=\"updateColors()\" [sj]=\"{ p: 1, bg: 'primary.main', c: 'primary.contrast', borderRadius: '4px', cursor: 'pointer' }\"&gt;\n      Update Pink Color\n    &lt;/button&gt;\n  `\n})\n\nexport class PaletteUpdateDemoComponent {\n  constructor(private sjTheme: SjThemeService) {}\n  updateColors(): void {\n    this.sjTheme.setTheme({\n      colors: {\n        pink: {\n          50: '#FCE4EC',\n          100: '#F8BBD0',\n          200: '#F48FB1',\n          300: '#F06292',\n          400: '#EC407A',\n          500: '#E91E63',\n          600: '#D81B60',\n          700: '#C2185B',\n          800: '#AD1457',\n          900: '#880E4F',\n          contrast: '#FFFFFF'\n        }\n      }\n    });\n  }\n}\n</code></pre>"},{"location":"colors/#color-palette-default-reference","title":"Color palette default reference","text":"Color 50 100 200 300 400 500 (default) 600 700 800 900 Contrast Blue #E3F2FD #BBDEFB #90CAF9 #64B5F6 #42A5F5 #3498DB #2E86C1 #1976D2 #1565C0 #0D47A1 #FFFFFF Indigo #E8EAF6 #C5CAE9 #9FA8DA #7986CB #5C6BC0 #3F51B5 #3949AB #303F9F #283593 #1A237E #FFFFFF Purple #F3E5F5 #E1BEE7 #CE93D8 #BA68C8 #AB47BC #9C27B0 #8E24AA #7B1FA2 #6A1B9A #4A148C #FFFFFF Pink #FCE4EC #F8BBD0 #F48FB1 #F06292 #EC407A #E91E63 #D81B60 #C2185B #AD1457 #880E4F #FFFFFF Red #FFEBEE #FFCDD2 #EF9A9A #E57373 #EF5350 #E74C3C #E53935 #D32F2F #C62828 #771010 #FFFFFF Orange #FFF3E0 #FFE0B2 #FFCC80 #FFB74D #FFA726 #F39C12 #FB8C00 #F57C00 #EF6C00 #bb4600 #000000 Yellow #FFFDE7 #FFF9C4 #FFF59D #FFF176 #FFEE58 #FFEB3B #FDD835 #FBC02D #F9A825 #F57F17 #000000 Green #E8F5E9 #C8E6C9 #A5D6A7 #81C784 #66BB6A #4CAF50 #43A047 #388E3C #2E7D32 #1B5E20 #FFFFFF Teal #E0F2F1 #B2DFDB #80CBC4 #4DB6AC #26A69A #009688 #00897B #00796B #00695C #004D40 #FFFFFF Cyan #E0F7FA #B2EBF2 #80DEEA #4DD0E1 #26C6DA #00BCD4 #00ACC1 #0097A7 #00838F #006064 #000000 Gray #FAFAFA #F5F5F5 #EEEEEE #E0E0E0 #BDBDBD #9E9E9E #757575 #616161 #424242 #212121 #000000 Black - - - - - #000000 - - - - - White - - - - - #FFFFFF - - - - - <p>\u2b05\ufe0f Previous: Styling Shortcuts | Next: Spacing \u27a1\ufe0f</p>"},{"location":"examples/","title":"SuperJSS Examples","text":"<p>Explore various examples to understand the capabilities and usage of SuperJSS.</p> <ul> <li>Demo App: this Project can be seen in StackBlitz,   ## Interactive Theming Demo</li> </ul> <p>This interactive demo provides a hands-on experience with the powerful theming capabilities of SuperJSS. Here's what you can explore:</p> <ul> <li>Live Theme Switching: Use the theme selector in the header to switch between different pre-built themes (e.g., Default, Desert, Ocean) and even a custom theme. Notice how the application's entire look and feel changes instantly.</li> <li>Dynamic Color Palette: The \"Palette\" section showcases the theme's color palette, including primary, secondary, tertiary, and other semantic colors. These colors automatically update when you switch themes.</li> <li> <p>Adaptive Typography: The \"Typography\" section demonstrates how headings, paragraphs, and other text elements adapt to the new theme's typography settings.</p> <p> </p> </li> </ul>"},{"location":"examples/#basic-usage","title":"Basic Usage","text":"<p>StackBlitz: Basic Usage Example</p> <p>This example demonstrates the basic usage of SuperJSS to create responsive designs.</p>"},{"location":"examples/#flex-box-responsive-demo","title":"Flex-box Responsive Demo","text":"<p>This interactive demo showcases how to leverage SuperJSS to create responsive flex-box layouts. Explore the code to see how <code>[sj]</code> attributes are used to define flexible and adaptive UI components.</p> <p>\u2190 Theming | Home </p>"},{"location":"faqs/","title":"FAQs \u2014 Super JSS (SJSS)","text":"<p>This FAQ consolidates the most common questions about Super JavaScript Stylesheets for Angular. If something is missing, open an issue \u2014 we\u2019ll add it.</p>"},{"location":"faqs/#basics","title":"Basics","text":"<ul> <li>Q: What is SJSS in one sentence?</li> <li> <p>A: A tiny, Angular\u2011native CSS\u2011in\u2011JS approach that turns JavaScript style objects into atomic CSS classes at runtime, with theming, responsive breakpoints, and pseudo\u2011selectors.</p> </li> <li> <p>Q: Is SJSS the same as inline styles?</p> </li> <li>A: No. You author JS objects, but SJSS emits real CSS classes and injects them once (deduped). You get proper cascade, media queries, and pseudo\u2011selectors (like <code>:hover</code>, <code>:focus</code>).</li> <li> <p>See also: Basic Usage</p> </li> <li> <p>Q: What Angular versions are supported?</p> </li> <li>A: Angular 20 for best results (Signals). Signals\u2011based reactivity is optimized for 20+.</li> </ul>"},{"location":"faqs/#tailwind-material-other-tools","title":"Tailwind / Material / Other Tools","text":"<ul> <li>Q: Isn\u2019t Tailwind enough?</li> <li>A: Tailwind is great, but ships a huge utility set whether you use it or not (you purge, but you still carry mental overhead). SJSS generates only what you use on demand. It\u2019s also very natural in Angular templates with Signals and typed configs.</li> <li> <p>See also: Basic Usage, Responsive Styling</p> </li> <li> <p>Q: Do I need Angular Material?</p> </li> <li>A: No. Use SJSS alone or combine them: SJSS for layout, tokens, and dynamic theming; Material for ready\u2011made components if you like.</li> </ul>"},{"location":"faqs/#how-does-sjss-compare-quick-view","title":"How does SJSS compare (quick view)?","text":"Library Type Theming/Tokens Angular 20 Tailwind CSS Utility framework Config\u2011based Generic Angular Material Component library Material tokens Yes PrimeNG Component library Theme packs Yes MUI (React) Component library Rich (React) No SJSS Styling library Tokens + responsive Yes <ul> <li>Q: How does SJSS compare to styled\u2011components or Emotion?</li> <li>A: Those are component\u2011scoped CSS\u2011in\u2011JS for React. SJSS is Angular\u2011native, atomic, and signal\u2011driven. Similar flexibility (theming, pseudo\u2011selectors), different ecosystem and ergonomics.</li> </ul>"},{"location":"faqs/#how-it-works","title":"How It Works","text":"<ul> <li>Q: How do I write styles?</li> <li>A: Provide a style object (or an array of objects to compose) to <code>[sj]</code>. Numeric values go through the theme\u2019s <code>spacing()</code>; strings pass through unchanged and can reference theme tokens.</li> </ul> <p><pre><code>&lt;div [sj]=\"{\n  d: 'flex', fxJustify: 'center',\n  p: { xs: 1, md: 2 },          // responsive padding\n  bg: 'primary.main',           // themed color\n  '&amp;:hover': { bg: 'primary.dark' }\n}\"&gt;&lt;/div&gt;\n</code></pre>   - See also: Basic Usage, Styling Shortcuts, Examples</p> <ul> <li>Q: What are the class names like?</li> <li>A: Atomic and predictable: <code>sj-{kebab-prop}-{value}</code>. Responsive: <code>sj-{prop}-{bp}-{value}</code>. Pseudo\u2011variant prefixes: <code>hover-sj-{prop}-{value}</code>.</li> </ul> <p>Examples:   - <code>sj-bg-primary_main</code>   - <code>sj-p-md-2</code>   - <code>hover-sj-c-secondary_dark</code>   - See also: Basic Usage</p> <ul> <li>Q: What tokens can I use for colors?</li> <li>A: Palette (<code>primary.main</code>, <code>primary.dark</code>, <code>primary.contrast</code>, etc.) and scales (<code>blue.500</code>, <code>green.300</code>). Hex/rgb/hsl strings also work.</li> <li> <p>See also: Colors, Palette</p> </li> <li> <p>Q: What shorthands are available?</p> </li> <li>A: Padding/margin (<code>p, px, py, pt, pr, pb, pl, m, mx, my, mt, mr, mb, ml</code>), sizes (<code>w, h, minW, maxW, minH, maxH</code>), borders (<code>b, bt, br, bb, bl, bs, bw, bc, brad</code>), colors (<code>bg, c</code>), flexbox (<code>d, fxDir, fxWrap, fxFlow, fxJustify, fxAItems, fxAContent, fxOrder, fxGrow, fxShrink, fxBasis, fxASelf</code>).</li> <li> <p>See also: Styling Shortcuts</p> </li> <li> <p>Q: How do responsive values work?</p> </li> <li>A: Provide an object with keys in your theme breakpoints (<code>xs, sm, md, lg, xl, xxl</code>). Each key emits a min\u2011width media rule.</li> <li>See also: Responsive Styling</li> </ul>"},{"location":"faqs/#theming-typography","title":"Theming &amp; Typography","text":"<ul> <li>Q: How do I set or update the theme?</li> <li>A: Inject <code>SjThemeService</code> and call <code>setTheme(partialTheme)</code>. It deep\u2011merges, clears CSS cache, and re\u2011applies.</li> </ul> <p><pre><code>constructor(private th: SjThemeService) {}\ntoggleDark() { this.isDark = !this.isDark; this.th.setTheme(this.isDark ? desertDarkTheme : defaultTheme); }\n</code></pre>   - See also: Theming</p> <ul> <li>Q: Can I pre\u2011configure a theme?</li> <li>A: Yes, provide <code>SJ_THEME</code> with a theme at bootstrap/component level to set defaults.</li> <li> <p>See also: Theming</p> </li> <li> <p>Q: Does SJSS apply default typography?</p> </li> <li>A: Yes. The directive auto\u2011applies default typography for tags like <code>H1\u2026H6, P, SPAN, STRONG, BODY, CAPTION, SMALL</code>. Your <code>[sj]</code> styles merge on top.</li> <li> <p>See also: Typography</p> </li> <li> <p>Q: How do I opt out of auto typography?</p> </li> <li>A: Options:<ul> <li>Override via <code>[sj]</code> (e.g., set your own <code>fontSize</code>, <code>lineHeight</code>, etc.).</li> <li>Use a wrapper element that doesn\u2019t match the auto tags.</li> <li>Define a neutral <code>typography.default</code> in your theme.</li> </ul> </li> <li>See also: Typography</li> </ul>"},{"location":"faqs/#units-values-and-gotchas","title":"Units, Values, and Gotchas","text":"<ul> <li>Q: Why is my <code>zIndex: 10</code> becoming <code>10rem</code>?</li> <li>A: Numbers are interpreted via <code>spacing()</code> (by design). For unitless props (e.g., <code>zIndex</code>, <code>lineHeight</code>, <code>fontWeight</code>, <code>opacity</code>, <code>order</code>, <code>flexGrow</code>, <code>flexShrink</code>) pass strings: <code>'10'</code>, <code>'600'</code>, <code>'1.4'</code>.</li> <li> <p>See also: Spacing</p> </li> <li> <p>Q: Can I use raw CSS values?</p> </li> <li>A: Yes. Any string is emitted as\u2011is: <code>'2px solid'</code>, <code>'100%'</code>, <code>'calc(100vh - 64px)'</code>, <code>'rgba(0,0,0,.1)'</code>.</li> <li> <p>See also: Basic Usage</p> </li> <li> <p>Q: Pseudo\u2011selectors support?</p> </li> <li>A: Supported via nested <code>&amp;:</code> keys (e.g., <code>&amp;:hover</code>, <code>&amp;:focus</code>). Complex combinators like <code>&amp; &gt; *</code> or <code>&amp; + *</code> are not supported yet.</li> <li> <p>See also: Styling Shortcuts</p> </li> <li> <p>Q: Custom media queries?</p> </li> <li>A: SJSS generates min\u2011width media queries based on your theme\u2019s <code>breakpoints</code>. When you update the theme via <code>SjThemeService.setTheme({ breakpoints: ... })</code>, the CSS cache is cleared and rules are regenerated \u2014 so the new breakpoint values take effect automatically. Arbitrary media features (e.g., <code>print</code>, <code>prefers-reduced-motion</code>, <code>orientation</code>) are not supported yet.</li> <li>See also: Responsive Styling</li> </ul>"},{"location":"faqs/#performance-css-output","title":"Performance &amp; CSS Output","text":"<ul> <li>Q: How big does the CSS get?</li> <li> <p>A: Only what you use. Rules are deduped by class name and appended to a single <code>&lt;style data-sjss&gt;</code> tag. If you generate many unique values (e.g., hundreds of unique pixel values), you\u2019ll grow the sheet accordingly.</p> </li> <li> <p>Q: How is reactivity handled?</p> </li> <li> <p>A: Angular Signals. Breakpoint and theme changes re\u2011render affected elements and reuse cached classes.</p> </li> <li> <p>Q: How do I clear the CSS?</p> </li> <li>A: Theme changes call <code>clearCache()</code> automatically. You can inject <code>SjCssGeneratorService</code> and call <code>clearCache()</code> manually if needed.</li> <li>See also: Theming</li> </ul>"},{"location":"faqs/#ssr-browser-support","title":"SSR &amp; Browser Support","text":"<ul> <li>Q: Does SSR work?</li> <li> <p>A: Client\u2011side is fully supported. SSR/Prerender is on the roadmap: collect generated CSS during server render, inline it with a nonce, and hydrate cache on the client to avoid flashes/duplication.</p> </li> <li> <p>Q: Browser support?</p> </li> <li>A: Evergreen browsers. No autoprefixer is bundled; modern CSS works as passed through. Add prefixes manually in style strings if you need legacy support.</li> </ul>"},{"location":"faqs/#interop-best-practices","title":"Interop &amp; Best Practices","text":"<ul> <li>Q: Can I use SJSS with Tailwind/Material/any CSS?</li> <li> <p>A: Yes. SJSS only adds classes; you can mix frameworks freely.</p> </li> <li> <p>Q: Will classes collide with mine?</p> </li> <li> <p>A: Class names are namespaced with <code>sj-</code> and include property/value segments. Collisions are unlikely. Specificity is low (single class) \u2014 apply order controls which wins.</p> </li> <li> <p>Q: How to avoid over\u2011generation?</p> </li> <li>A: Prefer tokens (<code>blue.500</code>, <code>primary.main</code>) and spacing units instead of many ad\u2011hoc pixel strings. Reuse composed style objects and arrays (e.g., <code>&lt;sj-card variant=\"...\"&gt;</code> with <code>[sj]</code> overrides).</li> <li> <p>See also: Styling Shortcuts, Colors, Spacing</p> </li> <li> <p>Q: Sticky header example?</p> </li> <li>A:   <pre><code>&lt;div [sj]=\"{ position: 'sticky', top: 0, zIndex: '1000' }\"&gt;\n  &lt;app-header&gt;&lt;/app-header&gt;\n&lt;/div&gt;\n</code></pre></li> <li> <p>See also: Examples</p> </li> <li> <p>Q: Dynamic theme toggle?</p> </li> <li>A:   <pre><code>isDark = false;\nconstructor(private th: SjThemeService) {}\ntoggle() { this.isDark = !this.isDark; this.th.setTheme(this.isDark ? desertDarkTheme : defaultTheme); }\n</code></pre></li> <li>See also: Theming</li> </ul>"},{"location":"faqs/#testing-troubleshooting","title":"Testing &amp; Troubleshooting","text":"<ul> <li>Q: How do I test styles?</li> <li> <p>A: In unit tests, render the element, then use <code>getComputedStyle(el)</code> for concrete values, or read the injected stylesheet\u2019s <code>textContent</code> for class rules.</p> </li> <li> <p>Q: My responsive styles don\u2019t apply.</p> </li> <li> <p>A: Ensure the viewport width triggers the breakpoint (in tests, set <code>window.innerWidth</code> and dispatch a <code>resize</code>). Also verify you used breakpoint keys present in your theme.</p> </li> <li> <p>Q: Styles appear but values are wrong.</p> </li> <li>A: Check units (numbers \u2192 spacing rem; unitless must be strings). Verify color tokens exist (<code>primary.contrast</code>, <code>blue.500</code>).</li> </ul>"},{"location":"faqs/#roadmap","title":"Roadmap","text":"<ul> <li>SSR/Prerender support with style registry and cache hydration</li> <li>Unitless property allowlist (e.g., <code>lineHeight</code>, <code>zIndex</code>) to avoid needing strings</li> <li>Custom media queries and variant plugins</li> <li>Optional autoprefix step for legacy browsers</li> </ul> <p>Have more questions? Open an issue or reach out \u2014 we\u2019re happy to help.</p>"},{"location":"installation/","title":"Installation of Super JavaScript Stylesheets (SJSS)","text":"<p>This section provides a step-by-step guide on installing and integrating Super JavaScript Stylesheets (SJSS) into your Angular projects, ensuring a smooth setup process.</p>"},{"location":"installation/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Prerequisites</li> <li>Installation Steps</li> <li>Integration</li> <li>Importing the Directive</li> </ol>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding with the installation of Super JavaScript Stylesheets (SJSS), make sure your development environment is ready:</p> <ul> <li> <p>Angular Project: An existing Angular project is required. If you don't have one, you can start by creating a new Angular project following the Angular documentation.</p> </li> <li> <p>Node.js and npm: Your machine must have Node.js and npm (Node Package Manager) installed. npm, which is essential for managing JavaScript packages, comes bundled with Node.js. You can verify the installation by running <code>node -v</code> and <code>npm -v</code> in your terminal.</p> </li> <li> <p>Super JSS Library: Familiarize yourself with the Super JSS library on npm. For detailed information, visit the Super JSS npm package page.</p> </li> </ul> <p>This update provides a clearer path for users to understand and prepare their environment for SJSS, including direct access to relevant resources.</p>"},{"location":"installation/#installation-steps","title":"Installation Steps","text":"<p>To install the Super JSS library, use the following npm command:</p> <pre><code>npm i super-jss\n</code></pre> <p>This command installs the latest version of Super JSS from npm.</p>"},{"location":"installation/#integration","title":"Integration","text":""},{"location":"installation/#importing-the-directive","title":"Importing the Directive","text":"<p>To integrate Super JSS into your Angular components, follow these steps:</p> <ol> <li>Import the SJSS Directive:</li> </ol> <p>First, import the <code>SjDirective</code> from the Super JSS package.</p> <pre><code>```typescript\nimport { SjDirective } from \"super-jss\";\n```\n</code></pre> <ol> <li>Applying the Directive:</li> </ol> <p>In your Angular component, apply the SJSS directive as shown below. This example sets the background color and padding for a div element.</p> <pre><code>```typescript\n@Component({\n  standalone: true,\n  selector: 'app-demo',\n  template: `\n    &lt;div [sj]=\"{backgroundColor: '#aa5645', padding: '10px'}\"&gt;\n      Welcome to Super JSS!\n    &lt;/div&gt;    \n  `\n})\nexport class DemoComponent {}\n```\n</code></pre> <p>For a live demonstration of Super JSS in action, visit our StackBlitz example.</p> <p>\u2b05\ufe0f Previous: Welcome to Super JSS | Next: Basic Usage \u27a1\ufe0f</p>"},{"location":"palette/","title":"Palette in SJSS","text":""},{"location":"palette/#introduction-to-palette-theming","title":"Introduction to Palette Theming","text":"<p>SJSS uses a theming approach that allows you to define semantic color sets, like primary, secondary, and tertiary, using the provided color palette. This approach ensures consistency in the application's color scheme and enhances the ease of applying styles.</p>"},{"location":"palette/#example-demonstrating-palette-with-shorthand-styles","title":"Example: Demonstrating Palette with Shorthand Styles","text":"<p>The palette's flexibility allows for easy styling of components with semantic colors. Here's an example showing palette usage with spacing shorthands:</p> <p><pre><code>  import { Component } from \"@angular/core\";\n  import { SjDirective } from \"super-jss\";\n\n  @Component({\n    standalone: true,\n    selector: 'app-themed-component',\n    template: `\n      &lt;div [sj]=\"{ bg: 'primary.main', c: 'primary.contrast', p: 2, m: 1}\"&gt;\n        Primary Themed Content\n        &lt;div [sj]=\"{ bg: 'secondary.light', c: 'secondary.contrast', p: 1, m: 0.5 }\"&gt;\n          Secondary Light Theme\n        &lt;/div&gt;\n        &lt;div [sj]=\"{ bg: 'success.main', c: 'success.contrast', p: 1, m: 0.5 }\"&gt;\n          Success Theme\n        &lt;/div&gt;\n      &lt;/div&gt;\n    `\n  })\n  export class ThemedComponent {}\n</code></pre> In this example:</p> <ul> <li>The outer div is styled with the primary color theme, along with padding (p) and margin (m) for spacing.</li> <li>The inner divs use the secondary and success color themes, each with their own padding and margin for clear visual separation.</li> </ul>"},{"location":"palette/#customizing-the-palette","title":"Customizing the palette","text":""},{"location":"palette/#structure-and-default-sets","title":"Structure and Default Sets","text":"<p>The default SJSS palette includes semantic color sets like primary, secondary, and success. Each set is structured with main, light, dark, and contrast shades for flexibility.</p>"},{"location":"palette/#updating-the-palette","title":"Updating the palette","text":"<p>To customize the palette according to your branding or design preferences:</p> <ol> <li>Use SjThemeService to apply a partial theme update at runtime.</li> <li>Modify semantic colors via setTheme({ palette: { ... } }):</li> </ol> <p><pre><code>import { Component } from \"@angular/core\";\nimport { SjDirective, SjThemeService } from \"super-jss\";\n\n@Component({\n  standalone: true,\n  selector: 'app-themed-component',\n  template: `\n    &lt;div (click)=\"updateColor()\" [sj]=\"{ bg: 'primary.main', c: 'primary.contrast', p: 2, m: 1}\"&gt;\n      Primary Themed Content\n    &lt;/div&gt;\n  `\n})\nexport class ThemedComponent {\n  constructor(private sjTheme: SjThemeService) {}\n  updateColor(): void {\n    this.sjTheme.setTheme({\n      palette: {\n        primary: {\n          main: '#ffdb58',\n          light: '#ffecb3',\n          dark: '#ffca28',\n          contrast: '#000000'\n        },\n        tertiary: {\n          main: '#9C27B0',\n          light: '#CE93D8',\n          dark: '#6A1B9A',\n          contrast: '#FFFFFF'\n        }\n      }\n    });\n  }\n}\n</code></pre> This example showcases how SJSS's theming and shorthand styles enable developers to create visually appealing and consistent designs with ease.</p>"},{"location":"palette/#default-palette-configuration","title":"Default palette configuration","text":"<p>The default palette configuration is as follows:</p> theme.palette. main light dark contrast primary blue[500] blue[300] blue[700] white secondary orange[500] orange[300] orange[700] black tertiary red[500] red[300] red[700] white success green[500] green[300] green[700] white info cyan[500] cyan[300] cyan[700] black warning orange[500] orange[300] orange[700] black error red[500] red[300] red[700] white dark gray[800] gray[600] black white neutral gray[500] gray[300] gray[700] black light gray[200] gray[50] gray[400] gray[900]"},{"location":"responsive-style/","title":"Responsive styling","text":"<p>Every property in SJSS accepts a responsive object: <code>{ xs, sm, md, lg, xl, xxl }</code>. Values cascade up\u2014smaller breakpoints apply to larger ones unless overridden.</p>"},{"location":"responsive-style/#examples","title":"Examples","text":"<p>Inline object</p> <pre><code>&lt;div [sj]=\"{\n  p: { xs: 1, md: 2 },\n  backgroundColor: { xs: 'light.light', md: 'primary.main' },\n  fontSize: { xs: 1, lg: 1.5 }\n}\"&gt;Responsive&lt;/div&gt;\n</code></pre> <p>With sj helpers and arrays</p> <pre><code>&lt;div [sj]=\"[\n  sj.p({ xs: 1, md: 2 }),\n  sj.bg({ xs: 'light.light', md: 'primary.main' }),\n  sj.d(sj.d.options.flex),\n  sj.fxDir({ xs: sj.fxDir.options.column, md: sj.fxDir.options.row }),\n  sj.justifyContent(sj.justifyContent.options.center),\n  sj.alignItems(sj.alignItems.options.center)\n]\"&gt;&lt;/div&gt;\n</code></pre> <p>On components (e.g., sj-paper)</p> <pre><code>&lt;sj-paper [sj]=\"[\n  sj.d(sj.d.options.flex),\n  sj.fxDir({ xs: sj.fxDir.options.column, md: sj.fxDir.options.row }),\n  sj.gap({ xs: 0.5, md: 1 })\n]\"&gt;&lt;/sj-paper&gt;\n</code></pre>"},{"location":"responsive-style/#breakpoints","title":"Breakpoints","text":"<p>Default breakpoint tokens: <code>xs, sm, md, lg, xl, xxl</code>. You can customize numeric values in your theme.</p> <p>Updating breakpoints at runtime</p> <pre><code>import { Component } from '@angular/core';\nimport { SjDirective, SjThemeService } from 'super-jss';\n\n@Component({\n  standalone: true,\n  imports: [SjDirective],\n  template: `&lt;button (click)=\"update()\" [sj]=\"sj.button.outlined({ px: 1 })\"&gt;Update breakpoints&lt;/button&gt;`\n})\nexport class Demo {\n  constructor(private sjTheme: SjThemeService) {}\n  update() {\n    this.sjTheme.setTheme({\n      breakpoints: { sm: 660, md: 980 }\n    });\n  }\n}\n</code></pre> <p>Notes</p> <ul> <li>Any property (shorthand or full CSS) can use a responsive object.</li> <li>Arrays merge left \u2192 right; responsive values are merged like regular ones.</li> <li>Prefer the root <code>sj</code> API for autocomplete and <code>.options</code>.</li> </ul> <p>See also: Basic usage, SJ API, and Styling shortcuts.</p> <p>\u2b05\ufe0f Previous: Styling Shortcuts | Next: Colors \u27a1\ufe0f</p>"},{"location":"sj-api/","title":"<code>sj</code> API","text":"<p><code>sj</code> is the single, typed entrypoint for Super JSS. It exposes:</p> <ul> <li>All CSS properties as functions directly at the root: <code>sj.display('flex')</code>, <code>sj.gridTemplateColumns('1fr 2fr')</code>.</li> <li>Curated shorthands at the root: <code>sj.p(1)</code>, <code>sj.bg('primary.main')</code>, <code>sj.fxJustify('space-between')</code>.</li> <li>Discoverable <code>.options</code> on popular props to reduce guesswork.</li> <li>Minimal tokens at root: <code>sj.palette</code> and <code>sj.breakpoints</code>.</li> <li>Blueprints at root with variants: <code>sj.sjCard</code>, <code>sj.sjButton</code>.</li> <li>Components for common UI: <code>&lt;sj-paper&gt;</code>, <code>&lt;sj-card&gt;</code>, <code>&lt;sj-button&gt;</code> (use <code>[variant]</code>).</li> <li>Host mode on surfaces: add <code>[host]</code> on <code>&lt;sj-paper&gt;</code> to apply styles to the parent element (wrapperless).</li> </ul> <p>This lean surface is SSR\u2011safe and designed for fast authoring with great IDE autocomplete.</p>"},{"location":"sj-api/#quick-examples","title":"Quick examples","text":"<pre><code>&lt;!-- CSS properties at root --&gt;\n&lt;div [sj]=\"[\n  sj.display('grid'),\n  sj.gridTemplateColumns({ xs: '1fr', sm: '25% 75%' })\n]\"&gt;&lt;/div&gt;\n\n&lt;!-- Popular shorthands at root --&gt;\n&lt;div [sj]=\"[\n  sj.p({ xs: 1, md: 2 }),\n  sj.bg(sj.palette.primary.light)\n]\"&gt;&lt;/div&gt;\n\n&lt;!-- Pseudo helpers accept a style or an array of styles --&gt;\n&lt;button [sj]=\"[\n  sj.bg('primary.main'),\n  sj.hover([ sj.bg('primary.dark'), sj.c('primary.contrast') ])\n]\"&gt;&lt;/button&gt;\n\n&lt;!-- Components with variants --&gt;\n&lt;sj-paper usePadding=\"default\" useRounded=\"default\"&gt;Surface&lt;/sj-paper&gt;\n&lt;sj-card [variant]=\"'flat'\" [sj]=\"{ p: 1 }\"&gt;Card&lt;/sj-card&gt;\n&lt;sj-card [variant]=\"'elevated'\"&gt;Card&lt;/sj-card&gt;\n\n&lt;!-- Tokens --&gt;\n&lt;div [sj]=\"[\n  sj.c(sj.palette.primary.contrast),\n  sj.bg(sj.palette.primary.dark),\n  sj.d(sj.d.options.grid)\n]\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"sj-api/#root-surface","title":"Root surface","text":"<ul> <li>CSS property functions: any camelCase CSS prop is available at <code>sj.&lt;prop&gt;(value)</code>.</li> <li>Examples: <code>sj.padding(...)</code>, <code>sj.backgroundColor(...)</code>, <code>sj.flexDirection(...)</code>, <code>sj.gridTemplateColumns(...)</code>.</li> <li> <p>Popular props include <code>.options</code> for discoverability:</p> <ul> <li><code>sj.display.options = { flex, grid, block, inline, inlineBlock, contents, none }</code></li> <li><code>sj.position.options = { static, relative, absolute, fixed, sticky }</code></li> <li><code>sj.width.options</code> / <code>sj.height.options</code> include sizing keywords like <code>auto</code>, <code>fitContent</code>, <code>maxContent</code>, <code>minContent</code>.</li> <li><code>sj.justifyContent.options</code> and <code>sj.alignItems.options</code> include friendly camelCase aliases like <code>spaceBetween</code>, <code>flexStart</code>.</li> </ul> </li> <li> <p>Shorthands (curated): <code>p, px, py, pt, pr, pb, pl, m, mx, my, mt, mr, mb, ml, gap, bg, c, w, h, minW, minH, maxW, maxH, brad, d, fxDir, fxJustify, fxAItems</code>.</p> </li> <li> <p>Shorthands also expose <code>.options</code> where it makes sense: <code>sj.bg.options</code>, <code>sj.c.options</code>, <code>sj.d.options</code>, <code>sj.fxDir.options</code>, <code>sj.fxJustify.options</code>, <code>sj.fxAItems.options</code>.</p> </li> <li> <p>Helpers:</p> </li> <li> <p><code>sj.hover(style | style[])</code>, <code>sj.focus(...)</code>, <code>sj.active(...)</code>, <code>sj.disabled(...)</code> \u2014 Pseudo helpers that accept a single style or an array of styles.</p> </li> <li> <p>Tokens:</p> </li> <li><code>sj.palette.&lt;name&gt;.&lt;shade&gt;</code> \u2014 semantic palette with <code>main|light|dark|contrast</code>.</li> <li> <p><code>sj.breakpoints = { xs, sm, md, lg, xl, xxl }</code> \u2014 breakpoint names for responsive objects.</p> </li> <li> <p>Blueprints (builders) at root:</p> </li> <li><code>sj.sjCard</code>, <code>sj.sjButton</code> are functions with dot\u2011variants, e.g. <code>sj.sjCard.elevated()</code>.</li> <li>Components accept a <code>variant</code> string (e.g. <code>'outlined'</code>), or use the blueprint helpers.</li> </ul>"},{"location":"sj-api/#responsive-values","title":"Responsive values","text":"<p>Any property or shorthand that accepts a value can take a responsive object:</p> <pre><code>{ xs: value, sm: value, md: value, lg: value, xl: value, xxl: value }\n</code></pre> <p>Example:</p> <pre><code>&lt;div [sj]=\"sj.flexDirection({ xs: 'column', sm: 'row' })\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"sj-api/#producer-pattern","title":"Producer pattern","text":"<p>Blueprints (and helpers) can be passed as functions (producers). The <code>[sj]</code> directive will call them for you, so both forms work:</p> <pre><code>&lt;div [sj]=\"sj.sjCard.primary\"&gt;&lt;/div&gt;\n&lt;div [sj]=\"sj.sjCard.primary()\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"sj-api/#tips","title":"Tips","text":"<ul> <li>Prefer <code>sj.&lt;cssProp&gt;</code> for maximum clarity; use shorthands for speed on common properties.</li> <li>Use <code>.options</code> on props and shorthands to avoid guessing string literals.</li> <li>Use <code>sj.palette</code> and responsive objects frequently; arrays merge left\u2192right, so keep overrides last.</li> </ul>"},{"location":"spacing/","title":"Spacing System","text":""},{"location":"spacing/#introduction-to-spacing","title":"Introduction to Spacing","text":"<p>In SJSS, spacing is a versatile feature that allows for consistent and scalable space management throughout your application. Spacing can be applied to various properties like padding, margin, gap, and others, using a simple numeric factor system.</p>"},{"location":"spacing/#default-spacing-configuration","title":"Default Spacing Configuration","text":"<p>The default spacing in SJSS is defined as a function that converts a numeric factor into rem units. This approach ensures uniformity and ease of adjustments across different UI components.</p>"},{"location":"spacing/#using-spacing","title":"Using Spacing","text":"<p>To apply spacing in SJSS, you can use shorthand properties with numeric factors. For example, <code>{ p: 1 }</code> translates to padding of 1 rem.</p> <p><pre><code>import { Component } from \"@angular/core\";\nimport { SjDirective } from \"super-jss\";\n\n@Component({\n  standalone: true,\n  selector: 'app-spacing-demo',\n  template: `&lt;div [sj]=\"{ p: 1, m: 2 }\"&gt;Content with padding and margin&lt;/div&gt;`\n})\nexport class SpacingDemoComponent {}\n</code></pre> In this example, <code>p: 1</code> applies 1 rem of padding, and <code>m: 2</code> applies 2 rem of margin to the element.</p> <p>You can also compose spacing responsively and with arrays:</p> <pre><code>&lt;div [sj]=\"[\n  { p: { xs: 1, md: 2 }, m: 1 },\n  { gap: { xs: 0.5, md: 1 } }\n]\"&gt;\n  Responsive spacing with gap\n&lt;/div&gt;\n</code></pre>"},{"location":"spacing/#customizing-spacing","title":"Customizing Spacing","text":"<p>You can customize the spacing scale to fit the design needs of your application.</p>"},{"location":"spacing/#updating-spacing","title":"Updating Spacing","text":"<p>The spacing can be updated using the <code>setTheme</code> method of <code>SjThemeService</code>. This method allows you to redefine how the numeric factors are translated into actual spacing values.</p> <pre><code>import { Component } from \"@angular/core\";\nimport { SjDirective, SjThemeService } from \"super-jss\";\n\n@Component({\n  standalone: true,\n  selector: 'app-spacing-update-demo',\n  template: `\n    &lt;button (click)=\"updateSpacing()\" [sj]=\"{ p: 1, bg: 'primary.main', c: 'primary.contrast', borderRadius: '4px', cursor: 'pointer' }\"&gt;\n      Update Spacing\n    &lt;/button&gt;\n  `\n})\nexport class SpacingUpdateDemoComponent {\n  constructor(private sjTheme: SjThemeService) {}\n  updateSpacing(): void {\n    this.sjTheme.setTheme({\n      spacing: (factor: number) =&gt; `${10 * factor}px` // Example: 1 unit now equals 10px\n    });\n  }\n}\n</code></pre>"},{"location":"spacing/#best-practices","title":"Best Practices","text":"<ul> <li>Use consistent spacing units across your application to maintain a harmonious layout.</li> <li>Choose spacing values that align with your design system or UI guidelines.</li> <li>Consider using multiples of a base unit (like 0.25 rem, 0.5 rem, etc.) for a harmonious and scalable spacing system.</li> </ul> <p>By utilizing SJSS's spacing system, developers can ensure consistent and easy-to-manage spacing throughout their Angular applications, with the flexibility to adjust it as per their design requirements.</p>"},{"location":"styling-shortcuts/","title":"Styling shorthands","text":"<p>SJSS provides a small, curated set of shorthands that cover the most common layout and spacing needs. You can always use any full CSS property in camelCase as well.</p> <p>Tip: Every shorthand accepts responsive values too, e.g. <code>p: { xs: 1, md: 2 }</code>.</p>"},{"location":"styling-shortcuts/#example-in-a-component","title":"Example in a component","text":"<pre><code>import { Component } from '@angular/core';\nimport { SjDirective } from 'super-jss';\n\n@Component({\n  standalone: true,\n  selector: 'app-shorthand-demo',\n  imports: [SjDirective],\n  template: `\n    &lt;div [sj]=\"{\n      py: 1,\n      px: 2,\n      m: 2,\n      border: '1px solid black',\n      d: 'flex',\n      fxJustify: 'center',\n      fxAItems: 'center',\n      gap: 1,\n      bg: '#aa5645'\n    }\"&gt;\n      Welcome to Super JSS!\n    &lt;/div&gt;\n  `,\n})\nexport class ShorthandDemoComponent {}\n</code></pre> <p>Prefer typed values and autocomplete? Use the root <code>sj</code> helper functions with <code>.options</code>:</p> <pre><code>&lt;div [sj]=\"[\n  sj.d(sj.d.options.flex),\n  sj.fxDir(sj.fxDir.options.row),\n  sj.fxJustify(sj.fxJustify.options.center),\n  sj.fxAItems(sj.fxAItems.options.center),\n  sj.p(2), sj.gap(1), sj.bg(sj.bg.options.primary.light)\n]\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"styling-shortcuts/#shorthand-reference","title":"Shorthand reference","text":""},{"location":"styling-shortcuts/#spacing","title":"Spacing","text":"Shorthand CSS Property Description <code>p</code> <code>padding</code> Padding (all sides) <code>pt</code> <code>paddingTop</code> Padding top <code>pr</code> <code>paddingRight</code> Padding right <code>pb</code> <code>paddingBottom</code> Padding bottom <code>pl</code> <code>paddingLeft</code> Padding left <code>px</code> <code>paddingLeft</code>, <code>paddingRight</code> Horizontal padding <code>py</code> <code>paddingTop</code>, <code>paddingBottom</code> Vertical padding <code>m</code> <code>margin</code> Margin (all sides) <code>mt</code> <code>marginTop</code> Margin top <code>mr</code> <code>marginRight</code> Margin right <code>mb</code> <code>marginBottom</code> Margin bottom <code>ml</code> <code>marginLeft</code> Margin left <code>mx</code> <code>marginLeft</code>, <code>marginRight</code> Horizontal margin <code>my</code> <code>marginTop</code>, <code>marginBottom</code> Vertical margin <code>gap</code> <code>gap</code> Gap between items"},{"location":"styling-shortcuts/#sizes","title":"Sizes","text":"Shorthand CSS Property Description <code>w</code> <code>width</code> Width <code>h</code> <code>height</code> Height <code>minW</code> <code>minWidth</code> Minimum width <code>minH</code> <code>minHeight</code> Minimum height <code>maxW</code> <code>maxWidth</code> Maximum width <code>maxH</code> <code>maxHeight</code> Maximum height"},{"location":"styling-shortcuts/#borders-radius","title":"Borders / radius","text":"Shorthand CSS Property Description <code>brad</code> <code>borderRadius</code> Border radius <p>Note: Use full CSS properties for borders (e.g., <code>border</code>, <code>borderTop</code>, <code>borderColor</code>, ...).</p>"},{"location":"styling-shortcuts/#colors","title":"Colors","text":"Shorthand CSS Property Description <code>bg</code> <code>backgroundColor</code> Background color <code>c</code> <code>color</code> Text color"},{"location":"styling-shortcuts/#flexbox-quick-layout","title":"Flexbox quick layout","text":"Shorthand CSS Property Description <code>d</code> <code>display</code> Display <code>fxDir</code> <code>flexDirection</code> Flex direction <code>fxJustify</code> <code>justifyContent</code> Main\u2011axis align <code>fxAItems</code> <code>alignItems</code> Cross\u2011axis align <p>Discover typed options on these shorthands via <code>sj.*.options</code> (e.g., <code>sj.d.options.flex</code>, <code>sj.fxDir.options.row</code>, <code>sj.bg.options.primary.main</code>).</p> <p>\u2b05\ufe0f Previous: Basic Usage | Next: Responsive Styling \u27a1\ufe0f</p>"},{"location":"theming/","title":"Comprehensive theming system","text":"<p>Super JSS provides a robust theming system that allows you to define and switch themes dynamically in your Angular applications. Theming is essential for creating consistent styling across your application and for enabling features like dark mode.</p>"},{"location":"theming/#defining-a-theme","title":"Defining a theme","text":"<p>You can define a theme as a set of style properties that can be applied globally across your application. Themes in SJSS conform to the <code>SjTheme</code> interface.</p> <p><pre><code>// src/app/my-custom-theme.ts\nimport { SjTheme, defaultTheme, deepMerge } from 'super-jss';\n\nexport const myCustomTheme: Partial&lt;SjTheme&gt; = deepMerge(defaultTheme, {\n  palette: {\n    primary: {\n      main: '#6200EE', // A custom primary color (Deep Purple)\n      light: '#9E47FF',\n      dark: '#0000AA',\n      contrast: '#FFFFFF',\n    },\n    secondary: {\n      main: '#03DAC6', // A custom secondary color (Teal)\n      light: '#66FFF9',\n      dark: '#00A896',\n      contrast: '#000000',\n    },\n  },\n  // You can override other theme properties like breakpoints, typography, spacing, etc.\n});\n</code></pre> (Note: <code>deepMerge</code> is an internal utility of the <code>super-jss</code> library. For external use, you might need to implement your own deep merge function or manually construct the theme object.)</p>"},{"location":"theming/#applying-a-theme","title":"Applying a theme","text":"<p>SJSS offers two primary ways to apply a theme:</p>"},{"location":"theming/#1-initial-theme-provision-at-application-startup","title":"1. Initial theme provision (at application startup)","text":"<p>To set a theme for your entire application at startup, provide it using the <code>SJ_THEME</code> injection token. This is typically done in your <code>main.ts</code> file for standalone applications or in your root <code>AppModule</code> for NgModule-based applications.</p> <pre><code>// src/main.ts (for standalone applications)\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { AppComponent } from './app/app.component';\nimport { SJ_THEME } from 'super-jss'; // Import the injection token\nimport { myCustomTheme } from './app/my-custom-theme'; // Your custom theme\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    { provide: SJ_THEME, useValue: myCustomTheme }\n  ]\n}).catch(err =&gt; console.error(err));\n</code></pre>"},{"location":"theming/#2-dynamic-theme-updates-at-runtime","title":"2. Dynamic theme updates (at runtime)","text":"<p>To change the theme dynamically based on user interaction, application state, or other logic, use the <code>SjThemeService</code>.</p> <pre><code>import { Component } from '@angular/core';\nimport { SjDirective, SjThemeService, defaultTheme } from 'super-jss';\nimport { myCustomTheme } from './my-custom-theme'; // Your custom theme\n\n@Component({\n  standalone: true,\n  selector: 'app-theme-switcher',\n  template: `\n    &lt;button (click)=\"toggleTheme()\" [sj]=\"{ p: 1, bg: 'primary.main', color: 'primary.contrast', borderRadius: '4px', cursor: 'pointer' }\"&gt;\n      Toggle Theme\n    &lt;/button&gt;\n  `,\n})\nexport class ThemeSwitcherComponent {\n  isCustomThemeActive = false;\n\n  constructor(private sjThemeService: SjThemeService) {}\n\n  toggleTheme(): void {\n    this.isCustomThemeActive = !this.isCustomThemeActive;\n    const themeToApply = this.isCustomThemeActive ? myCustomTheme : defaultTheme;\n    this.sjThemeService.setTheme(themeToApply);\n  }\n}\n</code></pre>"},{"location":"theming/#theme-aware-pseudo-selectors","title":"Theme-aware pseudo-selectors","text":"<p>SJSS allows you to define styles for pseudo-selectors (like <code>:hover</code>, <code>:active</code>, <code>:focus</code>) directly within your <code>[sj]</code> attribute. These pseudo-selector styles can also leverage your defined theme colors and properties.</p> <pre><code>import { Component } from '@angular/core';\nimport { SjDirective, sj } from 'super-jss';\n\n@Component({\n  standalone: true,\n  selector: 'app-themed-button',\n  template: `\n    &lt;button [sj]=\"[\n      { p: 1, bg: 'primary.main', c: 'primary.contrast', borderRadius: '4px', cursor: 'pointer', transition: 'all 0.3s ease-in-out' },\n      sj.hover({ bg: 'primary.dark', boxShadow: '0 4px 8px rgba(0,0,0,0.2)' }),\n      sj.active({ transform: 'scale(0.98)' })\n    ]\"&gt;\n      Themed Button\n    &lt;/button&gt;\n  `,\n})\nexport class ThemedButtonComponent {}\n</code></pre>"},{"location":"theming/#conclusion","title":"Conclusion","text":"<p>By following these steps, you can effectively define, apply, and dynamically switch themes in your Super JSS application, ensuring a consistent and customizable user experience.</p>"},{"location":"theming/#interactive-theming-demo","title":"Interactive theming demo","text":"<p>Open this StackBlitz to try theme switching live:</p> <p>sjss-theming-demo on StackBlitz</p> <p>\u2b05\ufe0f Previous: Typography | Next: Examples \u27a1\ufe0f</p>"},{"location":"typography/","title":"Typography system","text":"<p>SJSS offers a robust, theme-driven typography system you can customize per element (H1, P, etc.). Defaults are responsive across breakpoints.</p>"},{"location":"typography/#using-typography-in-components","title":"Using Typography in Components","text":"<p>To apply these typography styles in SJSS, you can use the <code>[sj]</code> directive in your Angular components. For example:</p> <p><pre><code>&lt;p [sj]&gt;This paragraph will use SJSS default styling.&lt;/p&gt;\n&lt;p [sj]=\"{ c: 'primary.main' }\"&gt;This paragraph will have the primary color.&lt;/p&gt;\n</code></pre> In these examples, the first paragraph will be rendered with the default SJSS styling for <code>&lt;p&gt;</code> elements. The second paragraph will additionally have a text color corresponding to the primary color from the palette.</p>"},{"location":"typography/#typography-default-styles","title":"Typography default styles","text":"<p>SJSS provides default styles for various HTML elements. These are defined in the theme and can be customized. Below are the defaults:</p> Element Font-Size (xs/md) Font-Weight Line-Height (xs/md) Default 1rem Normal 1.3 / 1.6 H1 2.5rem / 4rem 800 2.3 / 3.7 H2 2rem / 3.2rem 600 1.75 / 3.2 H3 1.75rem / 2.7rem 600 1.8 / 2.8 H4 1.5rem / 2rem 600 1.3 / 2.2 H5 1.25rem / 1.75rem 600 1.4 / 2.2 H6 1rem / 1.25rem 600 1.2 / 2.2 P 1rem Normal 1.6 / 1.8 SPAN 0.9rem Normal 1.2 / 1.4 STRONG 1rem Bold 1.2 / 1.4 BODY 1rem Normal 1.6 / 1.8 CAPTION 0.8rem Normal 1.2 / 1.4 SMALL 0.75rem Normal 0.5 / 0.75 PRE 0.9rem Monospace 1.2 / 1.4 <p>This table provides a comprehensive guide to the default typography settings in SJSS. Users can rely on this data to understand how text will be styled by default and make informed decisions about customizing these styles.</p>"},{"location":"typography/#customizing-typography","title":"Customizing typography","text":"<p>Use <code>SjThemeService.setTheme</code> to override specific typography entries by element key.</p> <pre><code>import { Component } from \"@angular/core\";\nimport { SjDirective, SjThemeService } from \"super-jss\";\n\n@Component({\n  standalone: true,\n  selector: 'app-typography-update-demo',\n  template: `\n    &lt;button (click)=\"updateFont()\" [sj]=\"{ p: 1, bg: 'primary.main', c: 'primary.contrast', borderRadius: '4px', cursor: 'pointer' }\"&gt;\n      Update H3 Font\n    &lt;/button&gt;\n  `\n})\nexport class TypographyUpdateDemoComponent {\n  constructor(private sjTheme: SjThemeService) {}\n  updateFont(): void {\n    this.sjTheme.setTheme({\n      typography: {\n        H3: {\n          fontSize: '2rem',\n          fontWeight: '600',\n          lineHeight: 3\n        }\n      }\n    });\n  }\n}\n</code></pre> <p>\u2b05\ufe0f Previous: Responsive Styles | Next: Theming \u27a1\ufe0f</p>"},{"location":"blueprints/_index/","title":"Blueprints overview","text":"<p>Blueprints are prebuilt style builders for common UI building blocks. Think of them as ergonomic factory functions that return an SjStyle you can plug straight into <code>[sj]</code>.</p> <ul> <li>Purpose: speed up layout and component styling with sensible defaults</li> <li>What they are: plain functions that return styles; you can pass overrides</li> <li>Where they live: exposed at the root API (sj.sjBox, sj.sjCard, sj.sjButton) and as named imports</li> <li>How they fit: combine them with any <code>sj.*</code> helpers and responsive values</li> </ul> <p>Why this is different</p> <ul> <li>Unlike design systems that ship heavy components, blueprints are style blueprints. They don\u2019t render elements or bring runtime weight\u2014they only return styles.</li> <li>You stay in control of markup and behavior while reusing good defaults.</li> </ul> <p>Two ways to use</p> <ol> <li>Direct import</li> </ol> <pre><code>import { SjDirective, sjBox } from 'super-jss';\n\n@Component({\n  standalone: true,\n  imports: [SjDirective],\n  template: `&lt;div [sj]=\"sjBox()\"&gt;Hello&lt;/div&gt;`\n})\nexport class Demo {\n  readonly sjBox = sjBox;\n}\n</code></pre> <ol> <li>Via sj root API (autocomplete + .options)</li> </ol> <pre><code>import { SjDirective, sj } from 'super-jss';\n\n@Component({\n  standalone: true,\n  imports: [SjDirective],\n  template: `\n    &lt;div [sj]=\"[\n      sj.sjBox.column({ gap: { xs: 0.5, md: 1 } }),\n      sj.p(2),\n      sj.bg(sj.bg.options.light.light)\n    ]\"&gt;&lt;/div&gt;\n  `\n})\nexport class DemoApi { readonly sj = sj; }\n</code></pre> <p>Available blueprints</p> <ul> <li>Box (sjBox): flex/grid layout helpers like row, column, centered, wrap, grow</li> <li>Card (sjCard): card surfaces with variants (outlined, flat, elevated, interactive, primary, secondary, info, codeSnippet)</li> <li>Button (sjButton): button styles with variants (contained, outlined, light, dark, secondary, danger, etc.)</li> </ul> <p>Next: see details and examples for each blueprint:</p> <ul> <li>Box \u2192 blueprints/box.md</li> <li>Cards \u2192 blueprints/cards.md</li> <li>Buttons \u2192 blueprints/buttons.md</li> </ul>"},{"location":"blueprints/buttons/","title":"Button Blueprints","text":"<p>Blueprints are style factories for common UI patterns. The Button blueprint returns styles for buttons (it doesn\u2019t render a component). If this is new to you, read the Blueprints overview. Use <code>sjButton</code> directly or via <code>sj.sjButton</code>; variants are discoverable via <code>sj.sjButton.variants</code>.</p>"},{"location":"blueprints/buttons/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Basic usage</li> <li>Using with sj root API</li> <li>Button variants<ul> <li>Default Button (Contained Primary)</li> <li>Light Button</li> <li>Contained Button</li> <li>Outlined Button</li> <li>Contained Light Button</li> <li>Contained Dark Button</li> <li>Contained Secondary Button</li> <li>Danger Button</li> </ul> </li> <li>Customizing buttons</li> </ol>"},{"location":"blueprints/buttons/#basic-usage","title":"Basic usage","text":"<p>The <code>sjButton</code> blueprint is a function that returns an <code>SjStyle</code> object. You can apply it directly to a <code>&lt;button&gt;</code> or <code>&lt;a&gt;</code> element using the <code>[sj]</code> directive.</p> <pre><code>import { Component } from '@angular/core';\nimport { SjDirective, sjButton } from 'super-jss';\n\n@Component({\n  standalone: true,\n  selector: 'app-my-button',\n  imports: [SjDirective],\n  template: `\n    &lt;button [sj]=\"sjButton()\"&gt;\n      Click Me\n    &lt;/button&gt;\n  `\n})\nexport class MyButtonComponent {\n  protected readonly sjButton = sjButton;\n}\n</code></pre>"},{"location":"blueprints/buttons/#using-with-sj-root-api","title":"Using with sj root API","text":"<p>Expose <code>sj</code> and compose with helpers and pseudo helpers (hover, active, disabled) if needed.</p> <pre><code>import { Component } from '@angular/core';\nimport { SjDirective, sj } from 'super-jss';\n\n@Component({\n  standalone: true,\n  selector: 'app-button-api',\n  imports: [SjDirective],\n  template: `\n    &lt;button [sj]=\"[\n      sj.sjButton(),\n      sj.p(1),\n      sj.hover([ sj.brad(0.75) ])\n    ]\"&gt;Primary Button&lt;/button&gt;\n\n    &lt;button [sj]=\"sj.sjButton.outlined({ c: 'secondary.main', borderColor: 'secondary.main' })\"&gt;\n      Custom Outlined\n    &lt;/button&gt;\n  `,\n})\nexport class ButtonApiComponent { readonly sj = sj; }\n</code></pre>"},{"location":"blueprints/buttons/#button-variants","title":"Button variants","text":"<p>The <code>sjButton</code> API provides several variants accessible via dot notation.</p>"},{"location":"blueprints/buttons/#default-button-contained-primary","title":"Default Button (Contained Primary)","text":"<p>The default button is a contained button with the theme's primary color. It includes a shadow and hover effects.</p> <ul> <li>Usage: <code>sjButton()</code> or <code>sjButton.containedPrimary()</code></li> </ul> <pre><code>&lt;button [sj]=\"sjButton()\"&gt;Primary Button&lt;/button&gt;\n</code></pre>"},{"location":"blueprints/buttons/#light-button","title":"Light Button","text":"<p>A light button with a subtle background and primary text color.</p> <ul> <li>Usage: <code>sjButton.light()</code></li> </ul> <pre><code>&lt;button [sj]=\"sjButton.light()\"&gt;Light Button&lt;/button&gt;\n</code></pre>"},{"location":"blueprints/buttons/#contained-button","title":"Contained Button","text":"<p>A contained button with a neutral background color.</p> <ul> <li>Usage: <code>sjButton.contained()</code></li> </ul> <pre><code>&lt;button [sj]=\"sjButton.contained()\"&gt;Contained Button&lt;/button&gt;\n</code></pre>"},{"location":"blueprints/buttons/#outlined-button","title":"Outlined Button","text":"<p>An outlined button with a transparent background and a border.</p> <ul> <li>Usage: <code>sjButton.outlined()</code></li> </ul> <pre><code>&lt;button [sj]=\"sjButton.outlined()\"&gt;Outlined Button&lt;/button&gt;\n</code></pre>"},{"location":"blueprints/buttons/#contained-light-button","title":"Contained Light Button","text":"<p>A contained button with a light background color.</p> <ul> <li>Usage: <code>sjButton.containedLight()</code></li> </ul> <pre><code>&lt;button [sj]=\"sjButton.containedLight()\"&gt;Light Contained&lt;/button&gt;\n</code></pre>"},{"location":"blueprints/buttons/#contained-dark-button","title":"Contained Dark Button","text":"<p>A contained button with a dark background color, suitable for dark themes.</p> <ul> <li>Usage: <code>sjButton.containedDark()</code></li> </ul> <pre><code>&lt;button [sj]=\"sjButton.containedDark()\"&gt;Dark Contained&lt;/button&gt;\n</code></pre>"},{"location":"blueprints/buttons/#contained-secondary-button","title":"Contained Secondary Button","text":"<p>A contained button using the theme's secondary color.</p> <ul> <li>Usage: <code>sjButton.containedSecondary()</code></li> </ul> <pre><code>&lt;button [sj]=\"sjButton.containedSecondary()\"&gt;Secondary Button&lt;/button&gt;\n</code></pre>"},{"location":"blueprints/buttons/#danger-button","title":"Danger Button","text":"<p>A button for actions that have destructive consequences, using the theme's error color.</p> <ul> <li>Usage: <code>sjButton.danger()</code></li> </ul> <pre><code>&lt;button [sj]=\"sjButton.danger()\"&gt;Danger Button&lt;/button&gt;\n</code></pre>"},{"location":"blueprints/buttons/#customizing-buttons","title":"Customizing buttons","text":"<p>All <code>sjButton</code> variants are functions that accept an <code>overrides</code> object, allowing you to customize any style property.</p> <pre><code>import { Component } from '@angular/core';\nimport { SjDirective, sjButton } from 'super-jss';\n\n@Component({\n  standalone: true,\n  selector: 'app-custom-button',\n  imports: [SjDirective],\n  template: `\n    // Override padding and border-radius\n    &lt;button [sj]=\"sjButton({ p: 2, borderRadius: 1 })\"&gt;\n      Custom Padding &amp; Radius\n    &lt;/button&gt;\n\n    // Make an outlined button use the secondary color\n    &lt;button [sj]=\"sjButton.outlined({ borderColor: 'secondary.main', c: 'secondary.main' })\"&gt;\n      Custom Outlined\n    &lt;/button&gt;\n  `\n})\nexport class CustomButtonComponent {\n  protected readonly sjButton = sjButton;\n}\n\nYou can also reference the variants registry: `sj.sjButton.variants.containedSecondary`, etc.\n</code></pre>"},{"location":"blueprints/cards/","title":"Card Blueprints","text":"<p>Blueprints are style builders (not components) that return <code>SjStyle</code> objects. The Card blueprint gives you reusable card surfaces. If you\u2019re new to the concept, see the Blueprints overview. Use <code>sjCard</code> directly or via <code>sj.sjCard</code> with autocomplete; variants are discoverable at <code>sj.sjCard.variants</code>.</p>"},{"location":"blueprints/cards/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Basic usage</li> <li>Using with sj root API</li> <li>Card variants<ul> <li>Default Card</li> <li>Outlined Card</li> <li>Flat Card</li> <li>Elevated Card</li> <li>Interactive Card</li> <li>Primary Card</li> <li>Secondary Card</li> <li>Info Card</li> <li>Code Snippet Card</li> </ul> </li> <li>Customizing cards</li> </ol>"},{"location":"blueprints/cards/#basic-usage","title":"Basic usage","text":"<p>The <code>sjCard</code> blueprint is a function that returns an <code>SjStyle</code> object. You can apply it directly to any element using the <code>[sj]</code> directive.</p> <pre><code>import { Component } from '@angular/core';\nimport { SjDirective, sjCard } from 'super-jss';\n\n@Component({\n  standalone: true,\n  selector: 'app-my-card',\n  imports: [SjDirective],\n  template: `\n    &lt;div [sj]=\"sjCard()\"&gt;\n      &lt;h3&gt;Default Card&lt;/h3&gt;\n      &lt;p&gt;This is a simple card using the default style.&lt;/p&gt;\n    &lt;/div&gt;\n  `\n})\nexport class MyCardComponent {\n  protected readonly sjCard = sjCard;\n}\n</code></pre>"},{"location":"blueprints/cards/#using-with-sj-root-api","title":"Using with sj root API","text":"<p>Expose <code>sj</code> and compose with helpers and responsive overrides.</p> <pre><code>import { Component } from '@angular/core';\nimport { SjDirective, sj } from 'super-jss';\n\n@Component({\n  standalone: true,\n  selector: 'app-card-api',\n  imports: [SjDirective],\n  template: `\n    &lt;div [sj]=\"[\n      sj.sjCard(),\n      sj.p({ xs: 1, md: 2 }),\n      sj.bg(sj.bg.options.light.light)\n    ]\"&gt;\n      Default via sj API\n    &lt;/div&gt;\n\n    &lt;div [sj]=\"sj.sjCard.elevated({ p: 2 })\"&gt;Elevated + overrides&lt;/div&gt;\n\n    &lt;div [sj]=\"sj.sjCard.primary({ gap: 1 })\"&gt;\n      &lt;h3 [sj]=\"sj.c(sj.c.options.primary.contrast)\"&gt;Primary Card&lt;/h3&gt;\n    &lt;/div&gt;\n  `,\n})\nexport class CardApiComponent { readonly sj = sj; }\n</code></pre>"},{"location":"blueprints/cards/#card-variants","title":"Card variants","text":"<p>The <code>sjCard</code> API comes with several convenient variants accessible via dot notation.</p>"},{"location":"blueprints/cards/#default-card","title":"Default Card","text":"<p>The default card comes with a light background, padding, and subtle transitions.</p> <ul> <li>Usage: <code>sjCard()</code></li> <li>Description: Default card with light background.</li> </ul> <pre><code>&lt;div [sj]=\"sjCard()\"&gt;...&lt;/div&gt;\n</code></pre>"},{"location":"blueprints/cards/#outlined-card","title":"Outlined Card","text":"<p>An outlined card has a transparent background and a visible border.</p> <ul> <li>Usage: <code>sjCard.outlined()</code></li> <li>Description: Outlined, transparent background, no shadow.</li> </ul> <pre><code>&lt;div [sj]=\"sjCard.outlined()\"&gt;...&lt;/div&gt;\n</code></pre>"},{"location":"blueprints/cards/#flat-card","title":"Flat Card","text":"<p>A flat card has no box shadow, making it appear flush with the background.</p> <ul> <li>Usage: <code>sjCard.flat()</code></li> <li>Description: No shadow.</li> </ul> <pre><code>&lt;div [sj]=\"sjCard.flat()\"&gt;...&lt;/div&gt;\n</code></pre>"},{"location":"blueprints/cards/#elevated-card","title":"Elevated Card","text":"<p>An elevated card has a more pronounced box shadow, making it appear to lift off the page.</p> <ul> <li>Usage: <code>sjCard.elevated()</code></li> <li>Description: Stronger shadow.</li> </ul> <pre><code>&lt;div [sj]=\"sjCard.elevated()\"&gt;...&lt;/div&gt;\n</code></pre>"},{"location":"blueprints/cards/#interactive-card","title":"Interactive Card","text":"<p>An interactive card includes hover effects, making it suitable for clickable elements.</p> <ul> <li>Usage: <code>sjCard.interactive()</code></li> <li>Description: Card with hover effects.</li> </ul> <pre><code>&lt;div [sj]=\"sjCard.interactive()\"&gt;...&lt;/div&gt;\n</code></pre>"},{"location":"blueprints/cards/#primary-card","title":"Primary Card","text":"<p>A card styled with the theme's primary color for the background and a contrasting text color.</p> <ul> <li>Usage: <code>sjCard.primary()</code></li> <li>Description: Primary background and contrast text.</li> </ul> <pre><code>&lt;div [sj]=\"sjCard.primary()\"&gt;...&lt;/div&gt;\n</code></pre>"},{"location":"blueprints/cards/#secondary-card","title":"Secondary Card","text":"<p>A card styled with the theme's secondary color.</p> <ul> <li>Usage: <code>sjCard.secondary()</code></li> <li>Description: Secondary background and contrast text.</li> </ul> <pre><code>&lt;div [sj]=\"sjCard.secondary()\"&gt;...&lt;/div&gt;\n</code></pre>"},{"location":"blueprints/cards/#info-card","title":"Info Card","text":"<p>A card for displaying informational messages, often with a subtle background.</p> <ul> <li>Usage: <code>sjCard.info()</code></li> <li>Description: Informational card with subtle background.</li> </ul> <pre><code>&lt;div [sj]=\"sjCard.info()\"&gt;...&lt;/div&gt;\n</code></pre>"},{"location":"blueprints/cards/#code-snippet-card","title":"Code Snippet Card","text":"<p>A specialized card style for displaying preformatted code.</p> <ul> <li>Usage: <code>sjCard.codeSnippet()</code></li> <li>Description: Preset style for code snippets inside cards.</li> </ul> <pre><code>&lt;pre [sj]=\"sjCard.codeSnippet()\"&gt;&lt;code&gt;...&lt;/code&gt;&lt;/pre&gt;\n</code></pre>"},{"location":"blueprints/cards/#customizing-cards","title":"Customizing cards","text":"<p>All <code>sjCard</code> variants are functions that accept an <code>overrides</code> object. This allows you to easily customize any style property of the card.</p> <pre><code>import { Component } from '@angular/core';\nimport { SjDirective, sjCard } from 'super-jss';\n\n@Component({\n  standalone: true,\n  selector: 'app-custom-card',\n  imports: [SjDirective],\n  template: `\n    // Override background color of a default card\n    &lt;div [sj]=\"sjCard({ bg: 'secondary.main', c: 'secondary.contrast' })\"&gt;\n      Custom Background\n    &lt;/div&gt;\n\n    // Override border radius of a primary card\n    &lt;div [sj]=\"sjCard.primary({ borderRadius: 4 })\"&gt;\n      Custom Border Radius\n    &lt;/div&gt;\n\n    // Override padding of an elevated card\n    &lt;div [sj]=\"sjCard.elevated({ p: 3 })\"&gt;\n      Custom Padding\n    &lt;/div&gt;\n  `\n})\nexport class CustomCardComponent {\n  protected readonly sjCard = sjCard;\n}\n\nYou can also use the variants registry for string\u2011based selections in other APIs: `sj.sjCard.variants.outlined`, etc.\n</code></pre>"},{"location":"blueprints/typography/","title":"Typography Blueprint","text":"<p>Typography blueprints in Super JSS provide consistent text styling with semantic variants. The <code>sjTypography</code> API offers functions for headings, body text, and other typography elements with responsive sizing and proper spacing.</p>"},{"location":"blueprints/typography/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Basic Usage</li> <li>Typography Variants</li> <li>Composing With Overrides</li> </ol>"},{"location":"blueprints/typography/#basic-usage","title":"Basic Usage","text":"<p>The <code>sjTypography</code> blueprint provides functions for different text styles. Each function returns an <code>SjStyle</code> object that can be applied to any element.</p> <pre><code>import { Component } from '@angular/core';\nimport { SjDirective, sjTypography } from 'super-jss';\n\n@Component({\n  standalone: true,\n  selector: 'app-typography-demo',\n  imports: [SjDirective],\n  template: `\n    &lt;div [sj]=\"sjTypography.h1()\"&gt;\n      &lt;h1&gt;Main Heading&lt;/h1&gt;\n    &lt;/div&gt;\n    &lt;div [sj]=\"sjTypography.body()\"&gt;\n      &lt;p&gt;Body text content&lt;/p&gt;\n    &lt;/div&gt;\n  `\n})\nexport class TypographyDemoComponent {\n  protected readonly sjTypography = sjTypography;\n}\n</code></pre>"},{"location":"blueprints/typography/#typography-variants","title":"Typography Variants","text":"Variant Description Typical Use Case <code>h1()</code> Largest heading, main page titles Page titles, hero sections <code>h2()</code> Section headings Major sections <code>h3()</code> Subsection headings Subsection headers <code>h4()</code> Smaller headings Component titles <code>h5()</code> Small headings Card titles, labels <code>h6()</code> Smallest headings Small labels <code>p()</code> Paragraph text Body paragraphs <code>body()</code> Default body text General content <code>span()</code> Inline text Inline elements <code>strong()</code> Bold/emphasized text Emphasized content <code>caption()</code> Small descriptive text Image captions, footnotes <code>small()</code> Fine print Legal text, disclaimers <code>pre()</code> Preformatted text Code blocks, monospace"},{"location":"blueprints/typography/#responsive-typography","title":"Responsive Typography","text":"<p>All typography variants include responsive font sizes that scale appropriately across breakpoints:</p> <pre><code>// h1 scales from 2.5rem (mobile) to 4rem (desktop)\nsjTypography.h1()\n\n// body text scales from 1rem (mobile) to 1.125rem (desktop)\nsjTypography.body()\n</code></pre>"},{"location":"blueprints/typography/#composing-with-overrides","title":"Composing With Overrides","text":"<p>Typography functions accept override objects to customize the base styles:</p> <pre><code>import { Component } from '@angular/core';\nimport { SjDirective, sjTypography } from 'super-jss';\n\n@Component({\n  standalone: true,\n  selector: 'app-custom-typography',\n  imports: [SjDirective],\n  template: `\n    &lt;div [sj]=\"sjTypography.h2({ color: 'primary.main', textAlign: 'center' })\"&gt;\n      &lt;h2&gt;Centered Primary Heading&lt;/h2&gt;\n    &lt;/div&gt;\n    &lt;div [sj]=\"sjTypography.body({ fontSize: 1.2, lineHeight: 1.8 })\"&gt;\n      &lt;p&gt;Larger body text with custom line height&lt;/p&gt;\n    &lt;/div&gt;\n  `\n})\nexport class CustomTypographyComponent {\n  protected readonly sjTypography = sjTypography;\n}\n</code></pre>"},{"location":"blueprints/typography/#direct-function-imports","title":"Direct Function Imports","text":"<p>For convenience, you can import specific typography functions directly:</p> <pre><code>import { sjH1, sjH2, sjBody, sjCaption } from 'super-jss';\n\n@Component({\n  template: `\n    &lt;h1 [sj]=\"sjH1({ color: 'primary.main' })\"&gt;Title&lt;/h1&gt;\n    &lt;p [sj]=\"sjBody()\"&gt;Content&lt;/p&gt;\n    &lt;span [sj]=\"sjCaption()\"&gt;Caption&lt;/span&gt;\n  `\n})\nexport class MyComponent {\n  protected readonly sjH1 = sjH1;\n  protected readonly sjBody = sjBody;\n  protected readonly sjCaption = sjCaption;\n}\n</code></pre>"},{"location":"blueprints/typography/#notes","title":"Notes","text":"<ul> <li>Typography variants include responsive font sizes, weights, and spacing</li> <li>All variants accept override objects for customization</li> <li>Use the <code>&lt;sj-typography&gt;</code> component for semantic HTML with variant props</li> <li>Typography styles follow your theme's design tokens</li> </ul>"},{"location":"components/_index/","title":"Components","text":"<p>These are lightweight, standalone wrappers powered by the same <code>[sj]</code> directive you use everywhere. Styling is applied via <code>[sj]</code> only; some components expose a <code>variant</code> input. There are no layout inputs like <code>display</code> or <code>gap</code>\u2014use the root <code>sj</code> API instead (e.g., <code>sj.sjBox.*</code>).</p> <ul> <li><code>&lt;sj-host&gt;</code> \u2014 Base wrapper that forwards <code>[sj]</code> to its parent</li> <li><code>&lt;sj-flex&gt;</code> \u2014 A powerful and flexible layout component for flexbox.</li> <li><code>&lt;sj-card&gt;</code> \u2014 Content container with variants + <code>[sj]</code> overrides</li> <li><code>&lt;sj-button&gt;</code> \u2014 Button styles with variants + <code>[sj]</code> overrides</li> </ul>"},{"location":"components/sj-button/","title":"sj-button","text":"<p><code>&lt;sj-button&gt;</code> is a surface-aware button component. It uses theme surfaces for padding/radius and provides simplified variants.</p> <p>Usage</p> <pre><code>&lt;!-- Filled (default) --&gt;\n&lt;sj-button&gt;\n  &lt;sj-typography variant=\"span\"&gt;Primary&lt;/sj-typography&gt;\n  &lt;!-- Use sj-typography for theme font/size --&gt;\n  &lt;!-- Color defaults to palette.primary --&gt;\n&lt;/sj-button&gt;\n\n&lt;!-- Outlined secondary --&gt;\n&lt;sj-button variant=\"outlined\" color=\"secondary\"&gt;\n  &lt;sj-typography variant=\"span\"&gt;Outlined&lt;/sj-typography&gt;\n  &lt;!-- Border uses palette.secondary.main --&gt;\n&lt;/sj-button&gt;\n\n&lt;!-- Flat link-style --&gt;\n&lt;sj-button variant=\"flat\"&gt;\n  &lt;sj-typography variant=\"span\"&gt;Flat&lt;/sj-typography&gt;\n&lt;/sj-button&gt;\n\n&lt;!-- Router selection (active) --&gt;\n&lt;sj-button routerLink=\"/home\" routerLinkActive=\"active\"&gt;\n  &lt;sj-typography variant=\"span\"&gt;Home&lt;/sj-typography&gt;\n&lt;/sj-button&gt;\n</code></pre> <p>API</p> Input Type Description <code>variant</code> <code>'filled'\\|'outlined'\\|'flat'</code> Visual variant (default <code>'filled'</code>) <code>color</code> <code>keyof SjPalette</code> Palette key for accents (default <code>'primary'</code>) <code>density</code> <code>1\\|2\\|3\\|4</code> Surface density for padding/radius (default <code>2</code>) <code>sj</code> <code>SjStyle\\|SjStyle[]</code> Overrides merged last <p>States</p> <ul> <li><code>:hover</code> \u2192 subtle lift; <code>:active</code> returns to rest</li> <li><code>:focus-visible</code> \u2192 2px outline with palette color</li> <li>Selected (persistent): <code>.active</code>, <code>[aria-current=\"page\"]</code>, <code>.selected</code> \u2192 subtle background + lift + soft shadow</li> </ul> <p>Notes</p> <ul> <li>Labels: wrap text with <code>&lt;sj-typography variant=\"span\"&gt;</code> to adopt theme typography</li> <li>Surface sizing: padding/radius come from theme surfaces (density)</li> <li><code>[sj]</code> overrides always merge last</li> </ul>"},{"location":"components/sj-card/","title":"sj-card","text":"<p>sj-card is a lean surface wrapper. It forwards to <code>&lt;sj-paper&gt;</code> under the hood and focuses on surface styling \u2014 not layout. Use <code>&lt;sj-flex&gt;</code> or <code>[sj]</code> inside the card for layout.</p> <p>Usage</p> <pre><code>&lt;sj-card variant=\"flat\" usePadding=\"default\"&gt;\n  &lt;h3 [sj]=\"{ m: 0 }\"&gt;Title&lt;/h3&gt;\n  &lt;p [sj]=\"{ m: 0 }\"&gt;Body&lt;/p&gt;\n  &lt;sj-button [variant]=\"'outlined'\" [sj]=\"{ px: 1 }\"&gt;Action&lt;/sj-button&gt;\n  &lt;!-- content --&gt;\n  &lt;!-- footer --&gt;\n  &lt;small [sj]=\"{ c: 'neutral' }\"&gt;Meta&lt;/small&gt;\n  &lt;!-- ... --&gt;\n&lt;/sj-card&gt;\n</code></pre> <p>API</p> Input Type Description <code>variant</code> <code>'flat'|'outlined'|'elevated'|'interactive'</code> Surface style and behavior <code>usePaint</code> <code>'none'|'auto'|paletteFamily</code> Full paint override; variant decides how to apply <code>usePadding</code> <code>1\\|2\\|3\\|4|'compact'|'default'|'comfortable'|'spacious'|'none'</code> Container padding from theme surfaces <code>useRounded</code> <code>1\\|2\\|3\\|4|'compact'|'default'|'comfortable'|'spacious'|'none'</code> Border radius from theme surfaces <code>sj</code> <code>SjStyle\\|SjStyle[]</code> Merges last; can override anything <p>Variants</p> <ul> <li>flat</li> <li>outlined</li> <li>elevated (adds shadow)</li> <li>interactive (hover raise)</li> </ul> <p>Override precedence</p> <ul> <li>The [sj] input merges after the variant, so your styles win.</li> </ul> <p>Notes</p> <ul> <li>For subtle color, prefer <code>[sj]=\"sj.bg('&lt;family&gt;.light')\"</code> and <code>sj.c('...')</code>. For full color, use <code>usePaint</code>.</li> <li>Layout is not part of the card API. Use <code>&lt;sj-flex&gt;</code> or <code>[sj]</code> inside the card for stacks/rows.</li> </ul>"},{"location":"components/sj-flex/","title":"<code>&lt;sj-flex&gt;</code>","text":"<p><code>&lt;sj-flex&gt;</code> is the primary component for creating flexbox layouts. It combines the power of the <code>[sj]</code> directive for detailed styling with convenient shortcuts for common flex patterns.</p>"},{"location":"components/sj-flex/#quick-start","title":"Quick Start","text":"<p>Use the <code>use*</code> inputs as shortcuts for common layouts, and the <code>[sj]</code> directive for fine-grained control over any CSS property.</p> <pre><code>&lt;!-- Simple centered layout with gap --&gt;\n&lt;sj-flex useCenter [sj]=\"{ gap: '1rem', padding: '2rem', background: '#f4f4f4', borderRadius: '8px' }\"&gt;\n  &lt;div&gt;Item 1&lt;/div&gt;\n  &lt;div&gt;Item 2&lt;/div&gt;\n&lt;/sj-flex&gt;\n\n&lt;!-- Responsive column/row layout --&gt;\n&lt;sj-flex [sj]=\"{ flexDirection: { xs: 'column', md: 'row' }, gap: 1 }\"&gt;\n  &lt;div&gt;Responsive Item 1&lt;/div&gt;\n  &lt;div&gt;Responsive Item 2&lt;/div&gt;\n&lt;/sj-flex&gt;\n</code></pre>"},{"location":"components/sj-flex/#api","title":"API","text":"Input Type Description <code>sj</code> <code>SjStyle \\| SjStyle[]</code> The primary way to apply detailed styles. Use for any CSS property, responsive values, and overrides. This input always has the final say. <code>component</code> <code>'div' \\| 'section' \\| ...</code> The HTML element to render (default: <code>'div'</code>). Allows for semantic markup. <code>host</code> <code>boolean</code> If <code>true</code>, styles are applied to the parent element and <code>&lt;sj-flex&gt;</code> removes itself from the DOM. <code>useCol</code> <code>boolean</code> Shortcut for <code>flex-direction: column</code>. <code>useWrap</code> <code>boolean</code> Shortcut for <code>flex-wrap: wrap</code>. <code>useInline</code> <code>boolean</code> Shortcut for <code>display: inline-flex</code>. <code>useCenter</code> <code>boolean</code> Shortcut for <code>justify-content: center</code> and <code>align-items: center</code>. <code>useBetween</code> <code>boolean</code> Shortcut for <code>justify-content: space-between</code>. <code>useAround</code> <code>boolean</code> Shortcut for <code>justify-content: space-around</code>. <code>useEvenly</code> <code>boolean</code> Shortcut for <code>justify-content: space-evenly</code>. <code>useGap</code> <code>1\\|2\\|3\\|4 \\| 'compact'\\|...</code> Applies a theme-based gap between items. <code>usePadding</code> <code>1\\|2\\|3\\|4 \\| 'compact'\\|...</code> Applies theme-based padding to the container. <code>useBg</code> <code>string \\| 'none'</code> Background color token or CSS color (e.g., <code>primary</code>, <code>primary.light</code>, <code>#111</code>, <code>white</code>). <code>useColor</code> <code>string \\| 'auto' \\| 'none'</code> Text color token or CSS color. <code>auto</code> picks <code>&lt;family&gt;.contrast</code> when <code>useBg</code> is a palette token."},{"location":"components/sj-flex/#key-concepts","title":"Key Concepts","text":""},{"location":"components/sj-flex/#layout-sugars","title":"Layout Sugars","text":"<p>The <code>use*</code> boolean inputs are designed for speed. You can combine them to create common layouts quickly.</p> <pre><code>&lt;sj-flex useCol useCenter useGap=\"default\"&gt;\n  &lt;!-- This will be a centered vertical stack with a default theme gap --&gt;\n&lt;/sj-flex&gt;\n</code></pre>"},{"location":"components/sj-flex/#fine-grained-control-with-sj","title":"Fine-Grained Control with <code>[sj]</code>","text":"<p>For any style not covered by the sugars, or for responsive control, use the <code>[sj]</code> directive. It accepts a style object or an array of them. Styles passed to <code>[sj]</code> will always override any styles generated by the <code>use*</code> inputs.</p> <pre><code>&lt;sj-flex useCol [sj]=\"{\n  justifyContent: 'flex-end', // Overrides any default justification\n  alignItems: { xs: 'stretch', md: 'center' }, // Responsive alignment\n  border: '1px solid token:light.dark' // Use theme tokens\n}\"&gt;\n  &lt;!-- Content --&gt;\n&lt;/sj-flex&gt;\n</code></pre>"},{"location":"components/sj-flex/#polymorphism-host-mode","title":"Polymorphism &amp; Host Mode","text":"<p>Like other base components, <code>&lt;sj-flex&gt;</code> can render as a different HTML element or apply its styles directly to its parent, giving you full control over the final DOM structure.</p> <pre><code>&lt;!-- Render as a &lt;section&gt; element --&gt;\n&lt;sj-flex component=\"section\"&gt;\n  ...\n&lt;/sj-flex&gt;\n\n&lt;!-- Apply flex styles directly to an existing div --&gt;\n&lt;div&gt;\n  &lt;sj-flex host useCenter&gt;\n    &lt;span&gt;Item 1&lt;/span&gt;\n    &lt;span&gt;Item 2&lt;/span&gt;\n  &lt;/sj-flex&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"components/sj-host/","title":"<code>&lt;sj-host&gt;</code>","text":"<p><code>sj-host</code> is a small utility component that lets you apply Super JSS styles when you need a helper wrapper (dynamic component host, layout slots, etc.) without leaving extra DOM once rendered.</p>"},{"location":"components/sj-host/#when-to-use-it","title":"When to use it","text":"<ul> <li>You are creating components dynamically and need a predictable anchor to   attach <code>[sj]</code> styles.</li> <li>You want a shorthand wrapper that merges with its parent instead of adding a   real <code>&lt;div&gt;</code>.</li> <li>You need to expose a <code>ViewContainerRef</code> for projected/dynamic child content   while keeping the <code>sj</code> directive behaviour.</li> </ul>"},{"location":"components/sj-host/#usage","title":"Usage","text":"<pre><code>&lt;sj-host [sj]=\"sj.sjBox.column({ gap: 1 })\"&gt;\n  &lt;h2&gt;Settings&lt;/h2&gt;\n  &lt;app-settings-panel&gt;&lt;/app-settings-panel&gt;\n&lt;/sj-host&gt;\n</code></pre> <ul> <li>Styles passed through <code>[sj]</code> are applied to the parent element once the   component renders. The <code>&lt;sj-host&gt;</code> tag removes itself after projection.</li> <li>Slots (<code>&lt;ng-content&gt;</code>) render normally; you can combine text, components, and   layout helpers freely.</li> </ul>"},{"location":"components/sj-host/#api","title":"API","text":"Input Type Description <code>sj</code> <code>SjStyle \\| SjStyle[]</code> Styles forwarded to the parent element."},{"location":"components/sj-host/#notes","title":"Notes","text":"<ul> <li>Because the styles move to the parent, make sure the parent is the element you   intend to style (e.g., wrap in another div if you need isolation).</li> <li><code>sj-host</code> depends on <code>SjDirective</code>, so all shorthand/responsive features are   available.</li> <li>The component exposes the underlying <code>ViewContainerRef</code> should you need it   when instantiating components programmatically.</li> </ul>"},{"location":"components/sj-icon/","title":"<code>&lt;sj-icon&gt;</code>","text":"<p><code>&lt;sj-icon&gt;</code> renders SVG icons with theme-aware styling. It provides a collection of built-in icons that automatically adapt to your theme colors.</p>"},{"location":"components/sj-icon/#quick-start","title":"Quick start","text":"<pre><code>&lt;sj-icon name=\"star\"&gt;&lt;/sj-icon&gt;\n&lt;sj-icon name=\"heart\" [sj]=\"{ color: 'primary.main' }\"&gt;&lt;/sj-icon&gt;\n&lt;sj-icon name=\"check\" size=\"2rem\" fill=\"green\"&gt;&lt;/sj-icon&gt;\n</code></pre>"},{"location":"components/sj-icon/#available-icons","title":"Available icons","text":"<p>The component includes a curated set of icons. Common ones include:</p> <ul> <li><code>star</code>, <code>heart</code>, <code>check</code>, <code>close</code>, <code>menu</code>, <code>search</code></li> <li><code>sun</code>, <code>moon</code>, <code>user</code>, <code>settings</code>, <code>bell</code></li> <li><code>arrow-left</code>, <code>arrow-right</code>, <code>arrow-up</code>, <code>arrow-down</code></li> <li><code>plus</code>, <code>minus</code>, <code>edit</code>, <code>trash</code>, <code>download</code>, <code>upload</code></li> </ul>"},{"location":"components/sj-icon/#inputs","title":"Inputs","text":"Input Type Description <code>name</code> <code>SjIconName</code> Icon identifier <code>size</code> <code>string \\| number</code> Icon size (CSS units) <code>fill</code> <code>string</code> Fill color (theme tokens or CSS colors) <code>stroke</code> <code>string</code> Stroke color <code>fillOpacity</code> <code>number</code> Fill opacity (0-1) <code>strokeOpacity</code> <code>number</code> Stroke opacity (0-1) <code>ariaHidden</code> <code>boolean</code> Hide from screen readers (default: true) <code>role</code> <code>string \\| null</code> ARIA role <code>label</code> <code>string \\| null</code> Accessible label <code>sj</code> <code>SjInput</code> Additional style overrides"},{"location":"components/sj-icon/#usage-examples","title":"Usage examples","text":""},{"location":"components/sj-icon/#basic-icons","title":"Basic icons","text":"<pre><code>&lt;sj-icon name=\"star\"&gt;&lt;/sj-icon&gt;\n&lt;sj-icon name=\"heart\"&gt;&lt;/sj-icon&gt;\n&lt;sj-icon name=\"check\"&gt;&lt;/sj-icon&gt;\n</code></pre>"},{"location":"components/sj-icon/#themed-icons","title":"Themed icons","text":"<pre><code>&lt;sj-icon name=\"sun\" [sj]=\"{ color: 'warning.main' }\"&gt;&lt;/sj-icon&gt;\n&lt;sj-icon name=\"moon\" fill=\"primary.main\"&gt;&lt;/sj-icon&gt;\n&lt;sj-icon name=\"bell\" stroke=\"secondary.main\" fillOpacity=\"0.8\"&gt;&lt;/sj-icon&gt;\n</code></pre>"},{"location":"components/sj-icon/#different-sizes","title":"Different sizes","text":"<pre><code>&lt;sj-icon name=\"star\" size=\"1rem\"&gt;&lt;/sj-icon&gt;\n&lt;sj-icon name=\"star\" size=\"2rem\"&gt;&lt;/sj-icon&gt;\n&lt;sj-icon name=\"star\" size=\"3rem\"&gt;&lt;/sj-icon&gt;\n</code></pre>"},{"location":"components/sj-icon/#accessible-icons","title":"Accessible icons","text":"<pre><code>&lt;sj-icon name=\"warning\" ariaHidden=\"false\" label=\"Warning message\" role=\"img\"&gt;&lt;/sj-icon&gt;\n</code></pre>"},{"location":"components/sj-icon/#with-custom-styling","title":"With custom styling","text":"<pre><code>&lt;sj-icon name=\"check\" size=\"1.5rem\" [sj]=\"{ color: 'success.main', cursor: 'pointer' }\" (click)=\"handleClick()\"&gt;&lt;/sj-icon&gt;\n</code></pre>"},{"location":"components/sj-icon/#notes","title":"Notes","text":"<ul> <li><code>&lt;sj-icon&gt;</code> is standalone; import it directly or via <code>SJ_BASE_COMPONENTS_IMPORTS</code></li> <li>Icons automatically adapt to theme changes</li> <li>Use theme tokens for <code>fill</code> and <code>stroke</code> to maintain consistency</li> <li>Set <code>ariaHidden=\"false\"</code> and provide <code>label</code> for interactive or decorative icons</li> <li>Icons are rendered as inline-flex elements with zero line-height</li> </ul>"},{"location":"components/sj-paper/","title":"sj-paper","text":"<p>sj-paper is a visual surface with simple variants and a few ergonomic sugars for padding, rounding, and colors.</p>"},{"location":"components/sj-paper/#usage","title":"Usage","text":"<pre><code>&lt;!-- Neutral surface (no spacing/rounding) --&gt;\n&lt;sj-paper variant=\"flat\"&gt;Content&lt;/sj-paper&gt;\n\n&lt;!-- Padding only (compact) --&gt;\n&lt;sj-paper usePadding=\"compact\"&gt;Content&lt;/sj-paper&gt;\n\n&lt;!-- Comfortable padding + rounded; override via [sj] if needed --&gt;\n&lt;sj-paper usePadding=\"comfortable\" useRounded=\"comfortable\" [sj]=\"{ gap: 0 }\"&gt;\n  Content\n&lt;/sj-paper&gt;\n\n&lt;!-- Color sugars (base component): tint vs paint --&gt;\n&lt;sj-paper [useBg]=\"'primary'\" [useColor]=\"'auto'\"&gt;Tinted surface&lt;/sj-paper&gt;\n&lt;sj-paper variant=\"outlined\" usePaint=\"primary\"&gt;Outlined paint&lt;/sj-paper&gt;\n&lt;sj-paper variant=\"filled\" usePaint=\"primary\"&gt;Filled paint&lt;/sj-paper&gt;\n\n&lt;!-- Override anything via [sj] (always wins) --&gt;\n&lt;sj-paper [sj]=\"{ p: 0, brad: 0 }\"&gt;Content&lt;/sj-paper&gt;\n</code></pre>"},{"location":"components/sj-paper/#inputs","title":"Inputs","text":"<ul> <li><code>variant</code>: <code>flat | outlined | filled</code></li> <li><code>usePadding</code>: <code>1|2|3|4 | 'compact'|'default'|'comfortable'|'spacious'|'none'|true|''</code> \u2014 theme density for padding</li> <li><code>useRounded</code>: <code>1|2|3|4 | 'compact'|'default'|'comfortable'|'spacious'|'none'|true|''</code> \u2014 theme density for border radius</li> <li><code>useBg</code>: <code>string | 'none'</code> \u2014 background token or CSS color; e.g., <code>primary</code>, <code>primary.light</code>, <code>#222</code>, <code>white</code></li> <li><code>useColor</code>: <code>string | 'auto' | 'none'</code> \u2014 text color token or CSS color; <code>auto</code> picks <code>&lt;family&gt;.contrast</code> when <code>useBg</code> is a palette token</li> <li><code>usePaint</code>: <code>'none'|'auto'|palette</code> \u2014 full paint override; behavior depends on <code>variant</code>:</li> <li><code>filled</code>/<code>default</code>: bg=<code>&lt;family&gt;.main</code>, color=<code>&lt;family&gt;.contrast</code></li> <li><code>outlined</code>: border/text=<code>&lt;family&gt;.main</code> (transparent bg)</li> <li><code>flat</code>: text=<code>&lt;family&gt;.main</code></li> <li><code>component</code>: render element tag (default <code>'div'</code>)</li> <li><code>host</code>: if <code>true</code>, apply styles to the parent and remove the wrapper</li> <li><code>[sj]</code>: fine-grained overrides (merges last and takes precedence)</li> </ul>"},{"location":"components/sj-paper/#precedence-and-merge-order","title":"Precedence and merge order","text":"<p>For sj-paper, styles merge in this order:</p> <ol> <li>Variant defaults (e.g., <code>outlined</code>, <code>filled</code>)</li> <li>Paper sugars: padding, rounded (via theme densities)</li> <li>Base sugars: <code>useBg</code>/<code>useColor</code> (can override variant background)</li> <li><code>[sj]</code> input (always final)</li> </ol>"},{"location":"components/sj-paper/#theme-hooks","title":"Theme hooks","text":"<p>Customize density maps under <code>theme.components.surfaces</code> (padding, radius). Values are numbers/responsive numbers that flow through <code>theme.spacing()</code>.</p>"},{"location":"components/sj-paper/#host-mode","title":"Host mode","text":"<pre><code>&lt;!-- Apply surface to the parent element (wrapperless) --&gt;\n&lt;div&gt;\n  &lt;sj-paper host usePadding=\"default\"&gt;\n    Content\n  &lt;/sj-paper&gt;\n  &lt;!-- sj-paper removes itself; the &lt;div&gt; becomes the surface --&gt;\n  &lt;!-- content becomes the parent\u2019s children --&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"components/sj-typography/","title":"<code>&lt;sj-typography&gt;</code>","text":"<p><code>&lt;sj-typography&gt;</code> provides consistent text styling with semantic variants. It renders text elements with predefined typography styles that follow your theme's design system.</p>"},{"location":"components/sj-typography/#quick-start","title":"Quick start","text":"<pre><code>&lt;sj-typography variant=\"h1\"&gt;Main Heading&lt;/sj-typography&gt;\n&lt;sj-typography variant=\"body\"&gt;Regular body text content&lt;/sj-typography&gt;\n&lt;sj-typography variant=\"caption\"&gt;Small caption text&lt;/sj-typography&gt;\n</code></pre>"},{"location":"components/sj-typography/#variants","title":"Variants","text":"Variant Description <code>h1</code> Largest heading, main page titles <code>h2</code> Section headings <code>h3</code> Subsection headings <code>h4</code> Smaller headings <code>h5</code> Small headings <code>h6</code> Smallest headings <code>p</code> Paragraph text <code>span</code> Inline text <code>strong</code> Bold/emphasized text <code>body</code> Default body text <code>caption</code> Small descriptive text <code>small</code> Fine print, legal text <code>pre</code> Preformatted text <code>default</code> Unstyled text (inherits from parent)"},{"location":"components/sj-typography/#inputs","title":"Inputs","text":"Input Type Description <code>variant</code> <code>SjTypographyVariant</code> Typography style variant <code>sj</code> <code>SjInput</code> Additional style overrides"},{"location":"components/sj-typography/#usage-examples","title":"Usage examples","text":""},{"location":"components/sj-typography/#headings-hierarchy","title":"Headings hierarchy","text":"<pre><code>&lt;sj-typography variant=\"h1\"&gt;Page Title&lt;/sj-typography&gt;\n&lt;sj-typography variant=\"h2\"&gt;Section Title&lt;/sj-typography&gt;\n&lt;sj-typography variant=\"h3\"&gt;Subsection Title&lt;/sj-typography&gt;\n&lt;sj-typography variant=\"h4\"&gt;Component Title&lt;/sj-typography&gt;\n</code></pre>"},{"location":"components/sj-typography/#mixed-content","title":"Mixed content","text":"<pre><code>&lt;sj-typography variant=\"body\"&gt;\n  This is regular body text with &lt;sj-typography variant=\"strong\"&gt;bold emphasis&lt;/sj-typography&gt; and\n  &lt;sj-typography variant=\"caption\"&gt;caption text&lt;/sj-typography&gt;.\n&lt;/sj-typography&gt;\n</code></pre>"},{"location":"components/sj-typography/#custom-styling","title":"Custom styling","text":"<pre><code>&lt;sj-typography variant=\"h2\" [sj]=\"{ color: 'primary.main', textAlign: 'center' }\"&gt;\n  Centered Primary Heading\n&lt;/sj-typography&gt;\n</code></pre>"},{"location":"components/sj-typography/#notes","title":"Notes","text":"<ul> <li><code>&lt;sj-typography&gt;</code> is standalone; import it directly or via <code>SJ_BASE_COMPONENTS_IMPORTS</code></li> <li>Variants follow semantic HTML conventions but with consistent theme-based styling</li> <li>Use <code>[sj]</code> input for additional customizations that override the variant styles</li> </ul>"},{"location":"components/surfaces-host-mode/","title":"Surfaces: Host vs Normal","text":"<p><code>&lt;sj-paper&gt;</code> can style itself (normal) or style its parent element (host mode). Host mode removes the wrapper so the parent becomes the surface.</p> <p>Why host mode? - Wrapperless DOM when you need to style an existing container - Keep semantics (e.g., style a native <code>&lt;section&gt;</code> or <code>&lt;a&gt;</code>)</p> <p>Normal usage (self-styled)</p> <pre><code>&lt;sj-paper variant=\"flat\" usePadding=\"default\" useRounded=\"default\"&gt;\n  Content\n  &lt;!-- The &lt;sj-paper&gt; element is the surface --&gt;\n&lt;/sj-paper&gt;\n</code></pre> <p>Host mode (wrapperless)</p> <pre><code>&lt;div&gt;\n  &lt;sj-paper host variant=\"elevated\" usePadding=\"default\" useRounded=\"default\"&gt;\n    Content\n  &lt;/sj-paper&gt;\n  &lt;!-- sj-paper removes itself; the &lt;div&gt; becomes the surface --&gt;\n&lt;/div&gt;\n</code></pre> <p>Live demo</p> <p> </p> <p>Notes</p> <ul> <li>Use <code>usePadding</code> and <code>useRounded</code> with density tokens ('compact'|'default'|'comfortable'|'spacious' or 1..4).</li> <li><code>[sj]</code> overrides always merge last.</li> <li>Cards forward to paper internally; host mode is provided by <code>&lt;sj-paper&gt;</code>.</li> </ul>"}]}