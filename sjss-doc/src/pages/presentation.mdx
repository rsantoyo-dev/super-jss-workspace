---
title: "Superâ€‘JSS Presentation"
description: "Slides for presenting Superâ€‘JSS. Big type for projection."
---

<style>{`
  /* Bigger type for live presenting */
  .deck h1 { font-size: 3rem; line-height: 1.15; margin: 0 0 1rem; }
  .deck h2 { font-size: 2.25rem; line-height: 1.2; margin: 2rem 0 0.75rem; }
  .deck h3 { font-size: 1.75rem; line-height: 1.25; margin: 1.25rem 0 0.5rem; }
  .deck p, .deck li { font-size: 1.35rem; line-height: 1.6; }
  .deck code { font-size: 1.1em; }
  .deck ul { margin-bottom: 1rem; }
  .deck hr { margin: 2rem 0; }
`}</style>

<div className="deck">

#SJSS

## Intro

- Styling Angular with Signals â€” Atomic CSS at Runtime
- Ship less CSS. Style with Signals. Theme everything at runtime.
- What SJSS is: Typed CSSâ€‘inâ€‘JS for Angular 20 (atomic, tokens, responsive)
- Agenda:
  - 1.  Atomic CSS via Angular Signals
  - 2.  Responsive + themeâ€‘driven styling (tokens + breakpoints)
  - 3.  Building blocks of Superâ€‘JSS

<small>
  Quick links: <a href="https://sjssdemo.netlify.app">Live demo</a>,
  <a href="https://www.npmjs.com/package/super-jss">npm</a>,
  <a href="https://github.com/rsantoyo-dev/super-jss-workspace">GitHub</a>,
  <a href="https://sjss.dev/docs/core/theming-typography">Typography</a>,
  <a href="https://sjss.dev/docs/core/theming-spacing">Spacing</a>,
  <a href="https://sjss.dev/docs/core/theming-padding">Padding densities</a>,
  <a href="https://sjss.dev/docs/core/theming-breakpoints">Breakpoints</a>,
  <a href="https://sjss.dev/docs/core/theming-colors">Colors</a>
</small>

<hr />

## Phase 0 â€” Responsive Style Engine (No Theme, No Signals)

### Goal

- Make any CSS property responsive from a plain TypeScript object.

```ts
// Allow values per breakpoint right on the object a developer writes.
export type ResponsiveStyle = {
  xs?: string | number;
  sm?: string | number;
  md?: string | number;
  lg?: string | number;
  xl?: string | number;
  xxl?: string | number;
};

// Every property from CSS.Properties can accept either a primitive or ResponsiveStyle.
type WithResponsive<T> = {
  [P in keyof T]: T[P] | ResponsiveStyle;
};

// Final SjStyle type: responsive core plus room for nested atoms (e.g. hover).
export type SjStyle = WithResponsive<CSS.Properties<string | number>> & {
  [key: string]: ResponsiveStyle | string | number | SjStyle | undefined;
};
```

<!-- becomes responsive padding (see example below) -->

This means every CSS property can now be expressed as:

```ts
{ padding: { xs: 4, md: 16 } } // becomes responsive padding
```

### Directive Logic

The `[sj]` directive was minimal:

- Read the `sj` object.
- Flatten responsive values for each breakpoint.
- Apply declarations directly to `HTMLElement.style`.

```ts
el.style.setProperty("padding", "4px");
```

```ts
const styles = this.cache.resolveAndMergeOnce(input);
for (const [prop, value] of flattenResponsive(styles, breakpoints)) {
  el.style.setProperty(prop, value);
}
```

### Output Example â€” Inline DOM Updates

With a responsive object like `{ padding: { xs: 4, md: 16 } }`, PhaseÂ 0 simply mutated `element.style`.

```html
<!-- viewport â‰¥ md -->
<div style="padding: 16px;"></div>
```

When the viewport collapsed to the `xs` breakpoint, the directive rewrote the inline style:

```html
<!-- viewport = xs -->
<div style="padding: 4px;"></div>
```

This is how the DOM behaved before hashing or class generation â€” just direct writes per breakpoint change.

```html
<div
  [sj]="{
        padding: '16px',
        backgroundColor: 'lightgray',
        maxWidth: '800px',
        width: '100%',
        margin: '0 auto'
      }"
>
  <h1
    [sj]="{
          fontSize: '24px',
          fontWeight: 'bold',
          marginBottom: '8px'
        }"
  >
    Welcome to Super JSS with Angular!
  </h1>
  <p
    [sj]="{
          fontSize: '16px',
          marginBottom: '8px'
        }"
  >
    This is a sample application demonstrating the use of Super JSS for styling
    Angular components.
  </p>
  <!-- create a loop of facts about super jss -->
  @for (fact of facts; track fact) {
  <p
    [sj]="{
          fontSize: '14px',
          marginBottom: '4px',
          padding: '8px 12px',
          backgroundColor: 'white',
          borderRadius: '4px'
        }"
  >
    - {{ fact }}
  </p>
  }
</div>
```

<iframe
  src="https://stackblitz.com/edit/sjss-base-sj-style?embed=1&file=src%2Fmain.ts&hideExplorer=1&hideNavigation=1&view=preview"
  title="SJSS â€¢ Base SjStyle"
  style={{
    width: "100%",
    height: 520,
    border: 0,
    borderRadius: 8,
    overflow: "hidden",
  }}
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; clipboard-write"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
/>

<small>
  If the embed doesnâ€™t load, open it directly:{" "}
  <a
    href="https://stackblitz.com/edit/sjss-base-sj-style?file=src%2Fmain.ts"
    target="_blank"
    rel="noreferrer noopener"
  >
    StackBlitz
  </a>
  .
</small>

No hashing, no caching, no classes â€” just inline responsive CSS at runtime.

### Problems Solved

- âœ… Angular devs could author styles as typed objects.
- âœ… Per-property responsive values with fill-forward semantics.
- âš™ï¸ Great playground for later features.

### Gaps Discovered

```
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â†“
Flatten responsive props
â†“
Apply to element.style
â†“
âœ… Works âŒ Not scalable
```

<small>Next: introduce caching, class generation, and theme awareness.</small>

<hr />

## Phase 1 â€” Hashing, Classes, and Deduplication

### Goal

- Escape inline styles and move toward reusable, hashed class names â€” preserving the responsive logic from Phase 0 but reducing DOM bloat.

### Mechanics

```ts
const className = generateAtomicClassName("", "padding", undefined, 16);

if (!this.generatedClasses.has(className)) {
  const cssRule = `.${className} { padding: 16px; }`;
  this.appendCss(cssRule); // inject into <style data-sjss>
  this.generatedClasses.add(className);
}

return className; // directive applies the class instead of inline styles
```

- Generates deterministic, atomic class names based on property/value.
- Injects CSS once per unique hash into a single managed `<style data-sjss>` tag.
- Caches results so the same declaration always reuses the same selector.

### Responsive Media Rules

```ts
const className = generateAtomicClassName("", "padding", "md", 16);
const rule =
  `@media (min-width: ${theme.breakpoints.md}px) {\n` +
  `  .${className} { padding: 16px; }\n}`;
cssMap.set(className, rule);
```

- Each responsive key (`sm`, `md`, `lg`, â€¦) becomes an `@media (min-width)` block.
- `xs` acts as the base declaration.
- Keeps the directive lightweight â€” it just switches from inline to class-based styling.

### âœ… Problems Solved

- Styles deduplicate across DOM elements through hashed class names.
- Media-aware CSS is centralized in a shared runtime stylesheet.
- Keeps build output lean â€” no precompiled CSS bundles yet required.

### âš ï¸ Remaining Gaps

- âŒ No theme token resolution yet (raw color/number values).
- âŒ CSS generation still done on-the-fly (no persisted cache).
- âŒ Signals not integrated â€” updates (theme, breakpoint) require manual refresh.

### ğŸ¯ 1. Architecture Flow (most important)

```
[ sj directive ]
  â”‚
  â–¼
Generate hash  â†’ "sj-pd16"
  â”‚
Check cache â”€â”€â”€â”
  â”‚        â”‚ (exists?)
  â–¼        â–¼
Create rule  <style data-sjss>
 .sj-pd16 { padding:16px }
  â”‚
Apply class="sj-pd16"
```

- Directive input â†’ hash â†’ style tag injection â†’ DOM reuse.
- Emphasizes deduplication and the single managed stylesheet.

| Phase 0                       | Phase 1                      |
| ----------------------------- | ---------------------------- |
| `<div style="padding:16px;">` | `<div class="sj-pd16">`      |
| Duplicate rules on every node | One `<style data-sjss>` host |
| Manual breakpoint juggling    | Media queries auto-generated |
| âŒ Non-scalable               | âœ… Atomic + cached           |

### Responsive Media Expansion

Input:

```ts
{ padding: { xs: 4, md: 16 } }
```

Output:

```css
.sj-pd4 {
  padding: 4px;
}
@media (min-width: 768px) {
}
```

<hr />

## Phase 2 â€” Signals & Theming (Reactive Engine)

### ğŸ§­ Goal

- Make styling reactive so SJSS responds automatically to:
  - ğŸŸ¢ Theme changes
  - ğŸŸ¢ Breakpoint updates
  - ğŸŸ¢ Window resize events
- Themes stay as plain objects, but are broadcast via Angular Signals.

### âš™ï¸ Core Mechanics

```ts
// Reactive state
currentBreakpoint = signal("xs");
windowWidth = signal(0);
themeVersion = signal(0);

// Theme signal
theme = signal(baseTheme);

// Derived signals
sjTheme = computed(() => this.theme());
themeName = computed(() => this.sjTheme().name);
breakpoint = computed(() => this.currentBreakpoint());
```

- `[sj]` directives subscribe to these signals.
- When `theme()` or `currentBreakpoint()` change, SJSS regenerates only the affected CSS and patches `<style data-sjss>`.
- Angular components avoid rerenders; the stylesheet reacts independently.

### ğŸ” Reactive Flow

```
       [ SJThemeService ]
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  theme()          currentBreakpoint() â”‚
â”‚      â”‚                   â”‚            â”‚
â”‚      â–¼                   â–¼            â”‚
â”‚   sjTheme()         breakpoint()      â”‚
â”‚        \             /                â”‚
â”‚         â–¼           â–¼                 â”‚
â”‚     computed signals                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚
           â–¼
   [sj] directive listens
           â”‚
           â–¼
 Updates <style data-sjss>
   (only changed rules)
```

#### Example usage (theming)

```ts
// Palette tokens via sj.* helpers (Phase 2)
// Applies theme primary light background + spacing scale 2
[sj.backgroundColor("primary.light"), sj.padding(2)];
```

ğŸŸ¢ SJSS becomes "alive"â€”styles react on demand as the environment shifts.

### âœ… Problems Solved

- Theme-aware updates: swapping themes restyles instantly.
- Breakpoint-aware layouts: resizing regenerates responsive rules.
- Zero manual refresh: signals keep directives and stylesheet in sync.

### âš ï¸ Still Missing

- âŒ Token resolution (colors/spacing/typography still raw values).
- âŒ Palette system â€” themes remain static objects.
- âŒ Persistent caching across sessions.

<small>
  Slide title:{" "}
  <strong>Phase 2 â€” Reactive Theming: When SJSS Became Alive</strong>
</small>

</div>

<hr />

## Phase 3 â€” sjRoot API (Authoring Intelligence)

### ğŸ§­ Goal

- Provide a typed, discoverable API in templates with great IDE autocomplete.
- Keep styles as plain JS objects under the hood; sj.\* just returns SjStyle parts you compose in an array.
- Encourage tokens + responsive objects without learning a new DSL.

### sjRoot API Basics

```ts
// Compose styles as an array of SjStyle parts
[
  sj.padding("16px"),
  sj.backgroundColor("primary.light"),
  sj.borderRadius("8px"),
][
  // Responsive values on any property
  sj.padding({ xs: "12px", md: "24px" })
][
  // Pseudo-states as helpers (also works with plain '&:hover')
  sj.hover([
    sj.transform("translateY(-1px)"),
    sj.boxShadow("0 8px 24px rgba(0,0,0,.16)"),
  ])
];
```

#### Typed Options (discoverable enums)

```ts
// Layout helpers expose typed options for great IDE autocomplete
[
  sj.d(sj.d.options.flex),
  sj.fxDir(sj.fxDir.options.row),
  sj.fxJustify(sj.fxJustify.options.center),
  sj.fxAItems(sj.fxAItems.options.center), // align-items: center
][
  // Shorthands + options work the same way
  (sj.p(1), sj.gap(sj.gap.options.default))
];
```

### sjRoot API â€” Map (high level)

```text
sj (root)
â”œâ”€ CSS properties (typed)      e.g. sj.backgroundColor(), sj.width(), sj.position()
â”œâ”€ Shorthands (curated)        e.g. sj.p(), sj.px(), sj.py(), sj.m(), sj.brad(), sj.bg(), sj.c()
â”œâ”€ Pseudo helpers              e.g. sj.hover([...]), sj.focus([...]), sj.active([...])
â”œâ”€ Layout aides                e.g. sj.d(), sj.fxDir(), sj.fxJustify(), sj.fxAItems(), sj.gap()
â”œâ”€ Tokens & options            sj.palette.*  â€¢  property.options (e.g. sj.d.options.flex)
â””â”€ Blueprints (thin presets)   sjPaper, sjCard, sjButton (opt-in, compose over sj)
```

### sjRoot API â€” Shortcut Map (detailed)

```text
Shorthands
  p, pt, pr, pb, pl, px, py          â†’ padding / axes / sides
  m, mt, mr, mb, ml, mx, my          â†’ margin / axes / sides
  brad                               â†’ borderRadius
  bg, c                              â†’ backgroundColor, color (accept tokens)
  w, h, minW, minH, maxW, maxH      â†’ sizing (typed keywords: auto, fit-content, â€¦)
  d                                  â†’ display (options: flex, grid, block, inline, â€¦)

Layout (Flex)
  fxDir      â†’ flex-direction (options: row, row-reverse, column, column-reverse)
  fxJustify  â†’ justify-content (options: start, end, center, between, around, evenly)
  fxAItems   â†’ align-items (options: start, end, center, stretch, baseline)
  fxWrap     â†’ flex-wrap (options: wrap, nowrap, wrap-reverse)
  gap        â†’ gap (density options: compact, default, comfortable, spacious)

Tokens & Options
  palette    â†’ sj.palette.<family>.<tone> (primary, secondary, â€¦ / main, light, dark, contrast)
  property.options.* â†’ discoverable enums per property (e.g., d.options.flex, fxDir.options.row)

Blueprints (compose over sj)
  sjPaper, sjCard, sjButton  â†’ thin presets that return SjStyle; optâ€‘in, no lockâ€‘in
```

### Why itâ€™s fast (ties to RIL)

- sj.\* returns plain objects â†’ the engine hashes shapes and uses a global cache.
- Responsive handling is precompiled to CSS media queries; resizes do not trigger JS work.
- Palette tokens map to CSS variables; theme swaps update vars at :root without re-injection.

<hr />

## Phase 4 â€” Components (Thin, Composable)

### ğŸ§­ Goal

- Offer small, focused UI primitives that layer helpful defaults over sjRoot.
- Keep them optional and composable â€” you can always drop to `[sj]` + `sj.*`.
- Standardize density, rounding, and paint semantics across the library.

### Components Overview

```text
sj-paper       Neutral surface wrapper (variants: default | filled | outlined | flat)
sj-card        Paper + layout sugar (content shell)
sj-button      Button styles (variants: filled | outlined | flat); token-aware paint
sj-flex        Thin flexbox helper with props for direction, wrap, gap
sj-typography  Named text variants (H1â€¦SMALL), themeâ€‘driven rhythm
sj-host        Hostâ€‘mode applicator (apply SJ styles to the parent element)
```

### Shared Props (density & rounding)

```text
usePadding  â†’ 'none' | 1..4 | 'compact' | 'default' | 'comfortable' | 'spacious'
useGap      â†’ same scale as usePadding (where supported)
useRounded  â†’ 'none' | 1..4 | 'compact' | 'default' | 'comfortable' | 'spacious'
usePaint    â†’ palette family ('primary' | 'secondary' | 'success' | â€¦) | 'auto' | 'none'
variant     â†’ componentâ€‘specific (e.g., paper: default | filled | outlined | flat)
```

### How They Work

- Components compose three layers (left â†’ right wins):
  1. variant defaults (e.g., outlined adds border)
  2. component sugars (e.g., usePadding/useRounded â†’ density maps)
  3. your `[sj]` styles (sjRoot array)
- Paint (`usePaint`) applies palette semantics consistently:
  - filled/default: `bg: <fam>.main`, `color: <fam>.contrast`
  - outlined: transparent bg, `border/text: <fam>.main`
  - flat: `text: <fam>.main`

### Examples

```ts
<sj-typography variant="p" [sj]="[sj.c('light.contrast')]">
        The theme palette defines semantic colors. Each color includes main,
        light, dark, and contrast variants.
      </sj-typography>

      @for (family of families; track family) {
      <sj-flex useCol useGap="compact">
        <sj-typography variant="h6" [sj]="[sj.c('light.contrast'), sj.m(0)]"
          >palette/light/{{ family }}</sj-typography
        >
        <div
          [sj]="[
            sj.d('grid'),
            sj.gridTemplateColumns({ xs: 'repeat(4, minmax(80px, 1fr))' }),
            sj.gap(sj.gap.options.default)
          ]"
        >
          @for (tone of tones; track tone) {
          <sj-paper
            useRounded="default"
            usePadding="compact"
            variant="flat"
            [sj]="[
              sj.bg(family + '.' + tone),
              sj.c(textColorFor(family, tone)),
              sj.minH('140px'),
              sj.position('relative'),
              sj.brad(0.75)
            ]"
          >
            <sj-typography variant="p">{{ tone }}</sj-typography>
            <sj-typography
              variant="small"
              [sj]="[
                sj.position('absolute'),
                sj.right(1),
                sj.bottom(1),
                sj.textAlign('right'),
                sj.p(sj.padding.options.compact)
              ]"
            >
              {{ hexFor(family, tone) }}<br />{{ rgbFor(family, tone) }}
            </sj-typography>
          </sj-paper>
          }
        </div>
      </sj-flex>
```

### Why Thin Components?

- They keep authoring ergonomic without trapping you; everything is still sjRoot.
- Density/rounding stay consistent via the themeâ€™s surfaces maps.
- Tokens flow through CSS variables (Phase 2), so theme swaps remain instant.

<hr />

## Theme Definition & Examples

<small>
  Docs quick links: <a href="../docs/core/theming-palette">Palette</a>,
  <a href="https://sjss.dev/docs/core/theming-typography">Typography</a>,
  <a href="https://sjss.dev/docs/core/theming-spacing">Spacing</a>,
  <a href="https://sjss.dev/docs/core/theming-padding">Padding densities</a>,
  <a href="https://sjss.dev/docs/core/theming-breakpoints">Breakpoints</a>,
  <a href="https://sjss.dev/docs/core/theming-colors">Colors</a>
</small>

### Type (simplified)

```ts
export type SjTheme = {
  name?: string;
  breakpoints?: SjBreakPoints; // xsâ€¦xxl
  spacing?: (factor: number) => string; // systemic spacing (1..20) â†’ rem
  typography?: SjTypography; // default + variants
  colors?: SjColors; // optional hue ladders
  palette?: SjPalette; // semantic families (primary, light, â€¦)
  components?: {
    surfaces?: {
      // Density maps: level (1..12) â†’ ResponsiveStyle | number | side map
      padding?: Partial<
        Record<
          1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,
          | ResponsiveStyle
          | number
          | {
              all?: ResponsiveStyle | number;
              x?: ResponsiveStyle | number;
              y?: ResponsiveStyle | number;
              top?: ResponsiveStyle | number;
              right?: ResponsiveStyle | number;
              bottom?: ResponsiveStyle | number;
              left?: ResponsiveStyle | number;
            }
        >
      >;
      gap?: Partial<
        Record<
          1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,
          ResponsiveStyle | number
        >
      >;
      radius?: Partial<
        Record<
          1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,
          ResponsiveStyle | number | string
        >
      >;
      border?: Partial<
        Record<
          1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,
          ResponsiveStyle | number
        >
      >;
    };
    // Optional asymmetric presets (arrays of SjStyle to spread into [sj])
    surfacesPresets?: {
      padding?: Partial<
        Record<1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12, SjStyle[]>
      >;
    };
  };
};
```

### Default Theme (excerpt)

```ts
export const defaultTheme: SjTheme = {
  name: "Default Light",
  breakpoints: { xs: 0, sm: 600, md: 960, lg: 1280, xl: 1920, xxl: 2560 },
  spacing: (n) => `${SYSTEMIC_SPACING(n)}rem`,
  typography: DEFAULT_TYPOGRAPHY,
  palette: {
    primary: {
      main: "#2C415C",
      light: "#8AA7BA",
      dark: "#25374E",
      contrast: "#FFFFFF",
    },
    light: {
      main: "#FFFFFF",
      light: "#F8FAFC",
      dark: "#F1F5F9",
      contrast: "#0B1220",
    },
    // â€¦secondary, success, info, warning, error, dark, neutral, tertiary
  },
  components: {
    surfaces: {
      padding: {
        1: { xs: 1, md: 2 },
        2: { xs: 2, md: 3, lg: 4 },
      },
      gap: { 1: { xs: 1, md: 2 } },
      radius: { 1: { xs: 1, md: 2 } },
      border: { 1: { xs: "0.065rem", md: "0.065rem" } },
    },
  },
};
```

### Using Themes at Runtime

```ts
// Inject SjThemeService
constructor(private theme: SjThemeService) {}

// Tweak a single token (no reset)
this.theme.setTheme({ palette: { primary: { main: '#7C3AED' } } });

// Replace from a clean base (no carryâ€‘over)
this.theme.setThemeReset(customDarkTheme);

// Update density maps (affects components using usePadding/useGap)
this.theme.setTheme({ components: { surfaces: { padding: { 2: { xs: 2, md: 3, lg: 4 } } } } });
```

Tips

- Prefer palette tokens in sjRoot (Phase 2) so theme swaps are instant via CSS variables.
- Drive density/rounding through the themeâ€™s `components.surfaces` maps for consistent spacing.

<hr />

## Live Examples (StackBlitz)

### Spacing Scale (1â€“20)

<iframe
  src="https://stackblitz.com/edit/sjss-spacing?embed=1&file=src%2Fmain.ts&hideExplorer=1&hideNavigation=1&view=preview"
  title="SJSS â€¢ Spacing Scale"
  style={{
    width: "100%",
    height: 520,
    border: 0,
    borderRadius: 8,
    overflow: "hidden",
  }}
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; clipboard-write"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
/>
<small>
  See the systemic spacing (1..20) and responsive objects in action.{" "}
  <a
    href="https://stackblitz.com/edit/sjss-spacing?file=src%2Fmain.ts"
    target="_blank"
    rel="noreferrer noopener"
  >
    Open
  </a>
</small>

### Palette Tokens (Theming)

<iframe
  src="https://stackblitz.com/edit/sjss-palette?embed=1&file=src%2Fmain.ts&hideExplorer=1&hideNavigation=1&view=preview"
  title="SJSS â€¢ Palette Tokens"
  style={{
    width: "100%",
    height: 520,
    border: 0,
    borderRadius: 8,
    overflow: "hidden",
  }}
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; clipboard-write"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
/>
<small>
  Use semantic tokens like 'primary.main' and 'light.light' â€” theme swaps update
  instantly via CSS variables.{" "}
  <a
    href="https://stackblitz.com/edit/sjss-palette?file=src%2Fmain.ts"
    target="_blank"
    rel="noreferrer noopener"
  >
    Open
  </a>
</small>

### Color Hues (Optional Ladders)

<iframe
  src="https://stackblitz.com/edit/sjss-colors?embed=1&file=src%2Fmain.ts&hideExplorer=1&hideNavigation=1&view=preview"
  title="SJSS â€¢ Colors"
  style={{
    width: "100%",
    height: 520,
    border: 0,
    borderRadius: 8,
    overflow: "hidden",
  }}
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; clipboard-write"
  sandbox="allow-forms allow-modals allow-presentation allow-same-origin allow-scripts"
/>
<small>
  Hue ladders (e.g., blue.500) when you need them â€” still theme-aware.{" "}
  <a
    href="https://stackblitz.com/edit/sjss-colors?file=src%2Fmain.ts"
    target="_blank"
    rel="noreferrer noopener"
  >
    Open
  </a>
</small>

### Typography Variants

<iframe
  src="https://stackblitz.com/edit/sjss-typography?embed=1&file=src%2Fmain.ts&hideExplorer=1&hideNavigation=1&view=preview"
  title="SJSS â€¢ Typography"
  style={{
    width: "100%",
    height: 520,
    border: 0,
    borderRadius: 8,
    overflow: "hidden",
  }}
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; clipboard-write"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
/>
<small>
  Themeâ€‘driven rhythm and variants (H1â€¦SMALL) with sjRoot overrides.{" "}
  <a
    href="https://stackblitz.com/edit/sjss-typography?file=src%2Fmain.ts"
    target="_blank"
    rel="noreferrer noopener"
  >
    Open
  </a>
</small>
